{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src\\interfaces\\CustomEvent.js",
    "src\\interfaces\\Document.js",
    "src\\interfaces\\Element.js",
    "src\\interfaces\\Event.js",
    "src\\interfaces\\EventTarget.js",
    "src\\interfaces\\HTMLSlotElement.js",
    "src\\interfaces\\HTMLTableElement.js",
    "src\\interfaces\\HTMLTableRowElement.js",
    "src\\interfaces\\HTMLTableSectionElement.js",
    "src\\interfaces\\Node.js",
    "src\\interfaces\\ShadowRoot.js",
    "src\\main.js",
    "src\\mixins\\ChildNode.js",
    "src\\mixins\\DocumentOrShadowRoot.js",
    "src\\mixins\\NonDocumentTypeChildNode.js",
    "src\\mixins\\NonElementParentNode.js",
    "src\\mixins\\ParentNode.js",
    "src\\mixins\\Slotable.js",
    "src\\patch.js",
    "src\\utils.js"
  ],
  "names": [],
  "mappings": "AAAA;ssBCeI,QAAA,GAAY,EAAM,GAAe,MAAA,iBAAA,KAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,KAAA,KACvB,EAAM,6BAHS;;;kmCCG7B,OAAA,QAAA,eAAY,kCAEN,QACF,qBAAsB,SAAS,UAAU,qBACzC,uBAAwB,SAAS,UAAU,uBAC3C,uBAAwB,SAAS,UAAU,uQAMtB,GAIjB,IAAK,GAHC,GAAa,OAAO,qBAAqB,KAAK,KAAM,GACpD,KAEG,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,QAAS,EAAK,aAAc,UAAU,KACtC,EAAS,KAAK,GAItB,MAAO,kDAIY,EAAI,GAIvB,IAAK,GAHC,GAAa,OAAO,uBAAuB,KAAK,KAAM,EAAI,GAC1D,KAEG,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,QAAS,EAAK,aAAc,UAAU,KACtC,EAAS,KAAK,GAItB,MAAO,kDAIY,GAInB,IAAK,GAHC,GAAa,OAAO,uBAAuB,KAAK,KAAM,MACtD,KAEG,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,QAAS,EAAK,aAAc,UAAU,KACtC,EAAS,KAAK,GAItB,MAAO,sCAYA,EAAM,GACb,GAAI,EAAK,WAAa,KAAK,eAAmC,iBAAlB,EAAK,SAC7C,KAAM,GAAE,UAAU,oBAGtB,OAAO,GAAE,MAAM,EAAM,KAAM,UA7DN;;;0qCCV7B,OAAA,QAAA,eAAY,kCAEZ,YAAA,QAAA,gFAEM,QACF,qBAAsB,QAAQ,UAAU,qBACxC,uBAAwB,QAAQ,UAAU,uBAC1C,uBAAwB,QAAQ,UAAU,uBAC1C,UAAW,OAAO,yBAAyB,QAAQ,UAAW,aAC9D,UAAW,OAAO,yBAAyB,QAAQ,UAAW,aAC9D,sBAAuB,QAAQ,UAAU,sBACzC,mBAAoB,QAAQ,UAAU,mBACtC,mBAAoB,QAAQ,UAAU,2PAkBzB,GAET,IAAK,GAAuB,SAAd,EAAK,MAAiC,WAAd,EAAK,KACvC,KAAM,GAAE,UAAU,YAGtB,IAA0B,iCAAtB,KAAK,aACL,KAAM,GAAE,UAAU,oBAGtB,QAAQ,KAAK,WACT,IAAK,UAAW,IAAK,QAAS,IAAK,aAAc,IAAK,OACtD,IAAK,MAAO,IAAK,SAAU,IAAK,KAAM,IAAK,KAAM,IAAK,KACtD,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,SAAU,IAAK,OACrD,IAAK,MAAO,IAAK,IAAK,IAAK,UAAW,IAAK,OACvC,KACJ,SACI,GAAI,EAAE,yBAAyB,KAAK,WAChC,KAEJ,MAAM,GAAE,UAAU,qBAG1B,GAAI,KAAK,WACL,KAAM,GAAE,UAAU,oBAGtB,IAAM,GAAS,KAAK,cAAc,wBAElC,GAAE,OAAO,EAAT,aAAA,SAEA,EAAE,OAAO,GACL,KAAM,KACN,KAAM,EAAK,KACX,gBAGJ,EAAE,OAAO,MACL,WAAY,EACZ,WAAY,MAAM,UAAU,MAAM,KAAK,KAAK,aAIhD,KAAK,GADC,GAAa,EAAE,OAAO,MAAM,WACzB,EAAI,EAAG,EAAI,EAAW,OAAQ,IACnC,EAAE,OAAO,EAAW,IAChB,WAAY,MAMpB,OAFA,QAAO,UAAU,IAAI,KAAK,KAAM,MAEzB,kCAgBH,GACJ,GAAI,GAAU,IAEd,GACI,IAAI,EAAQ,QAAQ,GAChB,MAAO,SAGR,EAAU,EAAQ,4DAIR,GAKjB,IAAK,GAJC,GAAc,KAAK,aAAc,UAAU,IAC3C,EAAa,OAAO,qBAAqB,KAAK,KAAM,GACpD,KAEG,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,KAAgB,EAAK,aAAc,UAAU,KAC7C,EAAS,KAAK,GAItB,MAAO,kDAIY,EAAI,GAKvB,IAAK,GAJC,GAAc,KAAK,aAAc,UAAU,IAC3C,EAAa,OAAO,uBAAuB,KAAK,KAAM,EAAI,GAC1D,KAEG,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,KAAgB,EAAK,aAAc,UAAU,KAC7C,EAAS,KAAK,GAItB,MAAO,kDAIY,GAKnB,IAAK,GAJC,GAAc,KAAK,aAAc,UAAU,IAC3C,EAAa,OAAO,uBAAuB,KAAK,KAAM,MACtD,KAEG,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,KAAgB,EAAK,aAAc,UAAU,KAC7C,EAAS,KAAK,GAItB,MAAO,iDAIW,EAAO,GACzB,MAAO,QAAO,sBAAsB,KAAK,KAAM,EAAO,iDAIvC,EAAO,GACtB,MAAO,QAAO,mBAAmB,KAAK,KAAM,EAAO,8CA0BpC,EAAU,GACzB,MAAO,QAAO,mBAAmB,KAAK,KAAM,EAAU,gCA3KtD,MAAO,MAAK,aAAa,sBAMpB,GAEL,KAAK,aAAa,OAAQ,sCA4D1B,GAAI,GAAa,EAAE,OAAO,MAAM,UAEhC,OAAK,IAAkC,WAApB,EAAW,KAIvB,EAHI,uCAgFX,MAAO,QAAO,UAAU,IAAI,KAAK,oBAIvB,GACV,MAAO,QAAO,UAAU,IAAI,KAAK,KAAM,qCAKvC,MAAO,QAAO,UAAU,IAAI,KAAK,oBAIvB,GACV,MAAO,QAAO,UAAU,IAAI,KAAK,KAAM,UA1KlB;;;4jCCpBvB,UAAY,GAAI,4BAIlB,QAAA,GAAY,EAAM,GAAe,gBAAA,KAAA,EAAA,IAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,KAAA,KACvB,EAAM,GADiB,OAG7B,WAAU,IAAV,EAAqB,GAAiB,EAAc,YAAa,GAHpC,+EAe7B,GAAM,MACA,EAAgB,KAAK,cAGrB,EAAO,cAAc,KAE3B,IAAI,YAAyB,QAAQ,CAAA,GAAA,IAAA,EAAA,GAAA,EAAA,EAAA,MAAA,KACjC,IAAA,GAAA,GAAA,EAAoB,EAApB,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAA0B,CAAA,GAAf,GAAe,EAAA,MAChB,EAAO,EAAM,IACf,aAAgB,MACX,EAAK,oBACN,EAAa,KAAK,GAItB,EAAa,KAAK,IATO,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,KAAA,GAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,KAAA,SAahC,IAAI,YAAyB,MAAM,CAAA,GAAA,IAAA,EAAA,GAAA,EAAA,EAAA,MAAA,KACpC,IAAA,GAAA,GAAA,EAAoB,EAApB,OAAA,cAAA,GAAA,EAAA,EAAA,QAAA,MAAA,GAAA,EAA0B,CAAA,GAAf,GAAe,EAAA,MAChB,EAAO,EAAM,IACd,GAAK,oBACN,EAAa,KAAK,IAJU,MAAA,GAAA,GAAA,EAAA,EAAA,EAAA,QAAA,KAAA,GAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,KAAA,SASpC,GAAa,KAAb,MAAA,EAAA,mBAAqB,GAGzB,OAAO,oCAmBP,MAAO,WAAU,IAAI,aAnEA;;;02BCFA;;;kmCCG7B,OAAA,QAAA,eAAY,0QAeM,GACV,GAAuB,SAAnB,KAAK,UAQT,MAAK,IAAW,EAAQ,WAAY,EAK7B,EAAE,uBAAuB,MAJrB,EAAE,OAAO,MAAM,2CAnB1B,MAAO,MAAK,aAAa,sBAIpB,GACL,KAAK,aAAa,OAAQ,UATL;;;kmCCR7B,OAAA,QAAA,eAAY,4QAKJ,GAAM,GAAU,KAAK,OACjB,IACA,EAAE,OAAO,EAAS,4CAKtB,GAAM,GAAQ,KAAK,KACf,IACA,EAAE,OAAO,EAAO,4CAKpB,GAAM,GAAQ,KAAK,KACf,IACA,EAAE,OAAO,EAAO,wCAId,GAKN,GAHI,KAAU,IACV,EAAQ,KAAK,KAAK,OAAS,GAE3B,EAAQ,GAAK,GAAS,KAAK,KAAK,OAChC,KAAM,GAAE,UAAU,iBAEtB,MAAK,KAAK,GAAO,gBA/BI;;;kmCCF7B,OAAA,QAAA,eAAY,uQAIG,GAKP,GAHI,KAAU,IACV,EAAQ,KAAK,MAAM,OAAS,GAE5B,EAAQ,GAAK,GAAS,KAAK,MAAM,OACjC,KAAM,GAAE,UAAU,iBAEtB,MAAK,MAAM,GAAO,gBAVG;;;kmCCF7B,OAAA,QAAA,eAAY,sQAIE,GAEN,GAAI,EAAQ,GAAK,GAAS,KAAK,KAAK,OAChC,KAAM,GAAE,UAAU,iBAEtB,MAAK,KAAK,GAAO,gBAPI;;;uyBCiW7B,QAAS,YAAW,EAAM,GACtB,GAAI,GAAS,EAAK,UAElB,GACI,IAAI,IAAW,EACX,OAAO,QAGR,EAAS,EAAO,WAEvB,QAAO,EAGX,QAAS,WAAU,EAAU,GACzB,QAAS,GAAkB,EAAQ,EAAU,GAEzC,IAAK,GADD,GAAW,EAAO,WACb,EAAI,EAAG,EAAI,EAAS,OAAQ,IAAK,CACtC,GAAI,GAAU,EAAS,EACvB,IAAI,IAAY,EACZ,OAAO,CAEN,IAAI,IAAY,EACjB,OAAO,GAMnB,GAAI,GAAY,EAAS,WACrB,EAAY,EAAS,UAEzB,IAAI,IAAc,EACd,MAAO,GAAkB,EAAU,EAOvC,KAHA,GAAI,IAAc,GACd,GAAc,GAEX,EAAY,EAAU,YACzB,EAAW,KAAK,EAGpB,MAAO,EAAY,EAAU,YACzB,EAAW,KAAK,EAGpB,GAAW,UACX,EAAW,SAMX,KAJA,GAGI,IAHO,KAAK,IAAI,EAAW,OAAS,EAAW,QACzC,KAAK,IAAI,EAAW,OAAQ,EAAW,QAEzC,GACD,EAAW,KAAO,EAAW,IAChC,GAGJ,OAAO,GAAkB,EAAW,EAAI,GAAI,EAAW,GAAI,EAAW,+TA1Z1E,OAAA,QAAA,eAAY,kCAEN,QACF,WAAY,OAAO,yBAAyB,KAAK,UAAW,cAC5D,cAAe,OAAO,yBAAyB,KAAK,UAAW,iBAC/D,cAAe,KAAK,UAAU,cAC9B,WAAY,OAAO,yBAAyB,KAAK,UAAW,cAC5D,WAAY,OAAO,yBAAyB,KAAK,UAAW,cAC5D,UAAW,OAAO,yBAAyB,KAAK,UAAW,aAC3D,gBAAiB,OAAO,yBAAyB,KAAK,UAAW,mBACjE,YAAa,OAAO,yBAAyB,KAAK,UAAW,eAC7D,YAAa,OAAO,yBAAyB,KAAK,UAAW,eAC7D,UAAW,KAAK,UAAU,iPAKd,GAGR,GAAM,GAAW,GAAY,EAAQ,YAAa,EAE9C,EAAA,OAAM,EAAA,MAIV,IAFA,EAAO,EAAW,MAEb,EAAU,CACX,KAAO,EAAW,EAAS,YACvB,EAAO,CAGX,OAAO,GAGX,KAAO,EAAW,EAAS,YACvB,EAAO,EAEe,iBAAlB,EAAK,WACL,EAAO,EAAW,EAAK,KAI/B,OAAO,2CA0BP,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,OAAI,GACO,EAAW,OAAS,EAGxB,OAAO,cAAc,KAAK,0CA8EjC,MAAO,QAAO,UAAU,KAAK,wCAIvB,GAKN,GAAsB,iBAAlB,KAAK,SACL,KAAM,GAAE,UAAU,oBAItB,OAAO,GAAE,MAAM,KAAM,OAAW,uCAIxB,GAGR,IAAK,EACD,OAAO,CAGX,IAAI,KAAK,WAAa,EAAM,SACxB,OAAO,CAGX,QAAQ,KAAK,UACT,IAAK,MAAK,mBACN,GAAI,KAAK,OAAS,EAAM,MACpB,KAAK,WAAa,EAAM,UACxB,KAAK,WAAa,EAAM,SACxB,OAAO,CAEf,KAAK,MAAK,aACN,GAAI,KAAK,eAAiB,EAAM,cAC5B,KAAK,SAAW,EAAM,QACtB,KAAK,YAAc,EAAM,WACzB,KAAK,WAAW,SAAW,EAAM,WAAW,OAC5C,OAAO,CAEf,KAAK,MAAK,eACN,GAAI,KAAK,eAAiB,EAAM,cAC5B,KAAK,YAAc,EAAM,WACzB,KAAK,QAAU,EAAM,MACrB,OAAO,CAEf,KAAK,MAAK,4BACN,GAAI,KAAK,SAAW,EAAM,QACtB,KAAK,OAAS,EAAM,KACpB,OAAO,CAEf,KAAK,MAAK,UACV,IAAK,MAAK,aACN,GAAI,KAAK,OAAS,EAAM,KACpB,OAAO,EAInB,GAAI,KAAK,UAAY,KAAK,aACtB,IAAK,GAAI,GAAI,EAAG,EAAI,KAAK,WAAW,OAAQ,IAAK,CAC7C,GAAI,GAAQ,KAAK,WAAW,GACxB,EAAQ,EAAM,WAAW,EAAM,KACnC,IAAI,EAAM,QAAU,EAAM,MACtB,OAAO,EAKnB,GAAI,GAAc,KAAK,WACnB,EAAc,EAAM,UACxB,IAAI,EAAY,SAAW,EAAM,WAAW,OACxC,OAAO,CAGX,KAAK,GAAI,GAAI,EAAG,EAAI,EAAY,OAAQ,IACpC,IAAK,EAAY,GAAG,YAAY,EAAY,IACxC,OAAO,CAIf,QAAO,kDAIa,GAGpB,GAAI,OAAS,EACT,MAAO,EAGX,IAAI,GAAQ,EACR,EAAQ,KACR,EAAQ,KACR,EAAQ,IAOZ,IALI,EAAM,UAAY,SAAS,UAAU,iBACrC,EAAQ,EACR,EAAQ,EAAM,cAGd,EAAM,UAAY,SAAS,UAAU,iBACrC,EAAQ,EACR,EAAQ,EAAM,aAEV,GAAS,GAAS,IAAU,GAE5B,IAAK,GADD,GAAQ,EAAM,YACT,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACnC,GAAM,GAAO,EAAM,EACnB,IAAI,EAAK,YAAY,GACjB,MAAO,UAAS,UAAU,0CACpB,SAAS,UAAU,2BAExB,IAAI,EAAK,YAAY,GACtB,MAAO,UAAS,UAAU,0CACpB,SAAS,UAAU,4BAMzC,MAAK,IAAU,GAAS,EAAM,gBAAkB,EAAM,cAMlD,WAAW,EAAO,IAAY,IAAU,GAAU,EAC3C,SAAS,UAAU,2BACpB,SAAS,UAAU,4BAGzB,WAAW,EAAO,IAAY,IAAU,GAAU,EAC3C,SAAS,UAAU,2BACpB,SAAS,UAAU,4BAGzB,UAAU,EAAO,GACV,SAAS,UAAU,4BAGvB,SAAS,UAAU,4BAnBf,SAAS,UAAU,0CACpB,SAAS,UAAU,4BACnB,SAAS,UAAU,gEAqBxB,GAGL,GAAI,GAAS,EAAK,UAElB,KAAK,EACD,OAAO,CAGX,GACI,IAAI,IAAW,KACX,OAAO,QAGR,EAAS,EAAO,WAEvB,QAAO,uCAIE,EAAM,GAIf,MAAO,GAAE,UAAU,EAAM,KAAM,uCAIvB,GAIR,MAAO,GAAE,OAAO,EAAM,2CAIb,EAAM,GAIf,MAAO,GAAE,QAAQ,EAAO,EAAM,0CAItB,GAIR,MAAO,GAAE,UAAU,EAAO,yCA7S1B,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,OAAI,GACO,EAGJ,OAAO,WAAW,IAAI,KAAK,4CAIlC,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,OAAI,GACI,EAAW,WAAa,KAAK,aACtB,EAEJ,KAGJ,OAAO,cAAc,IAAI,KAAK,yCAerC,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,OAAI,GACO,EAAW,QAGf,OAAO,WAAW,IAAI,KAAK,yCAKlC,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,OAAI,GACI,EAAW,OACJ,EAAW,GAEf,KAGJ,OAAO,WAAW,IAAI,KAAK,wCAKlC,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,OAAI,GACI,EAAW,OACJ,EAAW,EAAW,OAAS,GAEnC,KAGJ,OAAO,UAAU,IAAI,KAAK,8CAKjC,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CACZ,GAAM,GAAa,EAAE,OAAO,GAAY,WAClC,EAAe,EAAW,QAAQ,MAAQ,CAChD,OAAO,GAAe,EAAI,KAAO,EAAW,GAGhD,MAAO,QAAO,gBAAgB,IAAI,KAAK,0CAKvC,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CACZ,GAAM,GAAa,EAAE,OAAO,GAAY,WAClC,EAAe,EAAW,QAAQ,MAAQ,CAChD,OAAO,KAAiB,EAAW,OAAS,KAAO,EAAW,GAGlE,MAAO,QAAO,YAAY,IAAI,KAAK,0CAKnC,MAAO,QAAO,YAAY,IAAI,KAAK,oBAIvB,GACZ,MAAO,QAAO,YAAY,IAAI,KAAK,KAAM,UAhIpB;;;kmCCd7B,OAAA,QAAA,eAAY,qQAMJ,MAAO,4CAKP,MAAO,GAAE,OAAO,MAAM,kCAKtB,MAAO,GAAE,OAAO,MAAM,sDAQZ,WAtBW;;;qFCZ7B,GAAA,QAAA,QAAA,qDAEM,gBAAkB,gBAAkB,SAAQ,SAE7C,mBAAmB,OAAO,yBAC3B,EAAA,QAAA;;;kmCCQJ,OAAA,QAAA,eAAY,kDAEG,SAAA,GAAA,MAAA,UAAA,GAAA,QAAA,KAAA,MAAA,iBAAA,KAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,MAAA,KAAA,YAAA,MAAA,WAAA,EAAA,GAAA,aAAA,IAAA,IAAA,SAAA,MAAA,WAQP,GAAM,GAAS,KAAK,UAGpB,IAAK,EAAL,CARa,IAAA,GAcT,GAAwB,KAAK,gBAdpB,EAAA,UAAA,OAAP,EAAO,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAP,EAAO,GAAA,UAAA,EAeb,MAAO,GAAyB,EAAM,QAAQ,MAA2B,GACrE,EAAwB,EAAsB,eAKlD,IAAM,GAAO,EAAE,sBAAsB,EAAO,KAAK,cAK7C,GAD0B,OAA1B,EACwB,EAAO,WAGP,EAAsB,YAKlD,EAAE,UAAU,EAAM,EAAQ,OArCnB,IAAA,QAAA,MAAA,WA8CP,GAAM,GAAS,KAAK,UAGpB,IAAK,EAAL,CARY,IAAA,GAcR,GAAoB,KAAK,YAdjB,EAAA,UAAA,OAAP,EAAO,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAP,EAAO,GAAA,UAAA,EAeZ,MAAO,GAAqB,EAAM,QAAQ,MAAuB,GAC7D,EAAoB,EAAkB,WAK1C,IAAM,GAAO,EAAE,sBAAsB,EAAO,KAAK,cAIjD,GAAE,UAAU,EAAM,EAAQ,OAlEnB,IAAA,cAAA,MAAA,WA2EP,GAAM,GAAS,KAAK,UAGpB,IAAK,EAAL,CARkB,IAAA,GAcd,GAAoB,KAAK,YAdX,EAAA,UAAA,OAAP,EAAO,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAP,EAAO,GAAA,UAAA,EAelB,MAAO,GAAqB,EAAM,QAAQ,MAAuB,GAC7D,EAAoB,EAAkB,WAK1C,IAAM,GAAO,EAAE,sBAAsB,EAAO,KAAK,cAI7C,MAAK,YAAc,EACnB,EAAO,aAAa,KAAM,GAK1B,EAAO,aAAa,EAAM,OArGvB,IAAA,SAAA,MAAA,WA+GP,GAAM,GAAS,KAAK,UAEf,IAKL,EAAE,OAAO,KAAM,OAtHR,GAAsB;;;m8BCFtB,SAAU,GAErB,GAAM,IACF,cAAe,OAAO,yBAAyB,EAAK,UAAW,iBAGnE,OAAA,UAAA,GAAA,QAAA,KAAA,MAAA,iBAAA,KAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,MAAA,KAAA,YAAA,MAAA,WAAA,EAAA,GAAA,aAAA,IAAA,IAAA,gBAAA,IAAA,WAiBQ,MAAO,GAAO,cAAc,IAAI,KAAK,UAjB7C,GAAqB;;;knCCLV,SAAU,GAErB,GAAM,IACF,uBAAwB,OAAO,yBAAyB,EAAK,UAAW,0BACxE,mBAAoB,OAAO,yBAAyB,EAAK,UAAW,sBAGxE,OAAA,UAAA,GAAA,QAAA,KAAA,MAAA,iBAAA,KAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,MAAA,KAAA,YAAA,MAAA,WAAA,EAAA,GAAA,aAAA,IAAA,IAAA,yBAAA,IAAA,WAIQ,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CACZ,GAAM,GAAa,EAAE,OAAO,GAAY,WACpC,EAAQ,EAAW,QAAQ,KAE/B,IAAc,IAAV,EACA,MAAO,KAGX,GAAG,CACC,GAAM,GAAW,IAAa,EAE9B,IAAI,EAAS,WAAa,KAAK,aAC3B,MAAO,SAGR,EAAQ,EAEf,OAAO,MAGX,MAAO,GAAO,uBAAuB,IAAI,KAAK,SAzBtD,IAAA,qBAAA,IAAA,WA8BQ,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CACZ,GAAM,GAAa,EAAE,OAAO,GAAY,WACpC,EAAQ,EAAW,QAAQ,KAE/B,IAAI,IAAU,EAAW,OAAS,EAC9B,MAAO,KAGX,GAAG,CACC,GAAM,GAAW,IAAa,EAE9B,IAAI,EAAS,WAAa,KAAK,aAC3B,MAAO,SAGR,EAAQ,EAAW,OAE1B,OAAO,MAGX,MAAO,GAAO,mBAAmB,IAAI,KAAK,UAnDlD,GAAqB,GATzB,IAAA,QAAA,QAAA,eAAY;;;m8BCAG,SAAU,GAErB,GAAM,IACF,eAAgB,EAAK,UAAU,eAGnC,OAAA,UAAA,GAAA,QAAA,KAAA,MAAA,iBAAA,KAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,MAAA,KAAA,YAAA,MAAA,WAAA,EAAA,GAAA,aAAA,IAAA,IAAA,iBAAA,MAAA,SAGmB,GAKX,GAAM,GAAkB,EAAO,eAAe,KAAK,KAAM,GACnD,EAAgB,EAAgB,aAAc,UAAU,GAE9D,IAAI,OAAS,EACT,MAAO,EAKX,IAAI,GAAa,KAAK,UAEtB,KAAK,EACD,MAAO,KAKX,KAFA,GAAM,KAAW,KAAM,EAAY,UAAU,IAEtC,EAAM,QAAQ,CACjB,GAAM,GAAQ,EAAM,KAEpB,IAAI,EAAM,SACF,EAAM,KAAK,aACX,EAAM,MAAO,KAAM,EAAM,KAAK,YAAa,UAAU,QAGxD,CACD,GAAI,EAAM,KAAK,KAAO,EAClB,MAAO,GAAM,IAGjB,GAAM,MAAO,KAAM,EAAM,KAAM,UAAU,KAErC,EAAa,EAAM,KAAK,aACxB,EAAM,MAAO,KAAM,EAAY,UAAU,KAKrD,MAAO,UA9Cf,GAAqB;;;knCCHV,SAAU,GAErB,GAAM,IACF,SAAU,OAAO,yBAAyB,EAAK,UAAW,YAC1D,kBAAmB,OAAO,yBAAyB,EAAK,UAAW,qBACnE,iBAAkB,OAAO,yBAAyB,EAAK,UAAW,oBAClE,kBAAmB,OAAO,yBAAyB,EAAK,UAAW,qBAGvE,OAAA,UAAA,GAAA,QAAA,KAAA,MAAA,iBAAA,KAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,MAAA,KAAA,YAAA,MAAA,WAAA,EAAA,GAAA,aAAA,IAAA,IAAA,UAAA,MAAA,WAsEsB,IAAA,GAAA,GAAA,UAAA,OAAP,EAAO,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAP,EAAO,GAAA,UAAA,EAMd,IAAM,GAAO,EAAE,sBAAsB,EAAO,KAAK,cAIjD,GAAE,UAAU,EAAM,KAAM,KAAK,eAhFrC,IAAA,SAAA,MAAA,WAoFqB,IAAA,GAAA,GAAA,UAAA,OAAP,EAAO,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAP,EAAO,GAAA,UAAA,EAMb,IAAM,GAAO,EAAE,sBAAsB,EAAO,KAAK,cAGjD,GAAE,OAAO,EAAM,SA7FvB,IAAA,gBAAA,MAAA,SAiGkB,GACV,GAAM,GAAU,KAAK,iBAAiB,EAEtC,OAAI,GAAQ,OACD,EAAQ,GAGZ,QAxGf,IAAA,mBAAA,MAAA,SA4GqB,GAOb,GAAI,GAAa,KAAK,UAEtB,KAAK,EACD,MAAO,KAMX,KAHA,GAAM,KAAW,KAAM,EAAY,UAAU,IACvC,KAEC,EAAM,QAAQ,CACjB,GAAM,GAAQ,EAAM,KAEhB,GAAM,SACF,EAAM,KAAK,aACX,EAAM,MAAO,KAAM,EAAM,KAAK,YAAa,UAAU,KAIrD,EAAM,KAAK,UAAY,KAAK,cAAgB,EAAM,KAAK,QAAQ,IAC/D,EAAQ,KAAK,EAAM,MAGvB,EAAM,MAAO,KAAM,EAAM,KAAM,UAAU,KAErC,EAAa,EAAM,KAAK,aACxB,EAAM,MAAO,KAAM,EAAY,UAAU,KAKrD,MAAO,MAjJf,IAAA,WAAA,IAAA,WAIQ,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CAEZ,IAAK,GADD,MACK,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,GAAK,UAAY,KAAK,cACtB,EAAS,KAAK,GAItB,MAAO,GAGX,MAAO,GAAO,SAAS,IAAI,KAAK,SAjBxC,IAAA,oBAAA,IAAA,WAsBQ,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CACZ,IAAK,GAAI,GAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACxB,IAAI,EAAK,UAAY,KAAK,aACtB,MAAO,GAGf,MAAO,MAGX,MAAO,GAAO,kBAAkB,IAAI,KAAK,SAjCjD,IAAA,mBAAA,IAAA,WAsCQ,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CACZ,IAAK,GAAI,GAAI,EAAW,OAAS,EAAG,GAAK,EAAG,IAAK,CAC7C,GAAM,GAAO,EAAW,EACxB,IAAI,EAAK,UAAY,KAAK,aACtB,MAAO,GAGf,MAAO,MAGX,MAAO,GAAO,iBAAiB,IAAI,KAAK,SAjDhD,IAAA,oBAAA,IAAA,WAsDQ,GAAM,GAAa,EAAE,OAAO,MAAM,UAClC,IAAI,EAAY,CAEZ,IAAK,GADD,GAAQ,EACH,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CACxC,GAAM,GAAO,EAAW,EACpB,GAAK,UAAY,KAAK,cACtB,IAGR,MAAO,GAGX,MAAO,GAAO,kBAAkB,IAAI,KAAK,UAlEjD,GAAqB,GAXzB,IAAA,QAAA,QAAA,eAAY;;;kmCCDZ,OAAA,QAAA,eAAY,kDAEG,SAAA,GAAA,MAAA,UAAA,GAAA,QAAA,KAAA,MAAA,iBAAA,KAAA,GAAA,2BAAA,MAAA,EAAA,WAAA,OAAA,eAAA,IAAA,MAAA,KAAA,YAAA,MAAA,WAAA,EAAA,GAAA,aAAA,IAAA,IAAA,eAAA,IAAA,WAKP,MAAO,GAAE,UAAU,MAAM,OALlB,GAAsB;;;2UCOtB,WAIX,EAAE,OAAO,SAAT,WAAA,SACA,EAAE,OAAO,QAAT,UAAA,SAGA,EAAE,OAAO,mBAAT,kBAAA,SACI,mBAAqB,SAErB,EAAE,OAAO,gBAAT,kBAAA,SAEJ,EAAE,OAAO,iBAAT,mBAAA,SACA,EAAE,OAAO,wBAAT,0BAAA,SACA,EAAE,OAAO,oBAAT,sBAAA,SACA,EAAE,OAAO,KAAT,OAAA,SAIA,EAAE,OAAO,cAAc,EAAA,YAAA,SAAW,eAClC,EAAE,OAAO,SAAS,EAAA,YAAA,SAAW,UAC7B,EAAE,OAAO,eAAe,EAAA,YAAA,SAAW,gBAEnC,EAAE,OAAO,UAAU,EAAA,uBAAA,SAAsB,WACzC,EAAE,OAAF,aAAA,SAAsB,EAAA,uBAAA,SAAA,aAAA,UAEtB,EAAE,OAAO,SAAS,EAAA,2BAAA,SAA0B,UAC5C,EAAE,OAAO,eAAe,EAAA,2BAAA,SAA0B,gBAElD,EAAE,OAAO,UAAU,EAAA,uBAAA,SAAsB,WACzC,EAAE,OAAO,kBAAkB,EAAA,uBAAA,SAAsB,mBAEjD,EAAE,OAAO,UAAU,EAAA,aAAA,SAAY,WAC/B,EAAE,OAAO,kBAAkB,EAAA,aAAA,SAAY,mBACvC,EAAE,OAAO,SAAS,EAAA,aAAA,SAAY,UAE9B,EAAE,OAAO,SAAS,EAAA,WAAA,SAAU,UAC5B,EAAE,OAAO,MAAM,EAAA,WAAA,SAAU,OA3D7B,IAAA,QAAA,QAAA,cAAY,kCAEZ,aAAA,QAAA,kFACA,UAAA,QAAA,yEACA,SAAA,QAAA,sEACA,OAAA,QAAA,gEACA,aAAA,QAAA,kFACA,iBAAA,QAAA,8FACA,kBAAA,QAAA,iGACA,yBAAA,QAAA,sHACA,qBAAA,QAAA,0GACA,MAAA,QAAA,6DACA,YAAA,QAAA,+EAEA,WAAA,QAAA,wEACA,sBAAA,QAAA,yGACA,0BAAA,QAAA,qHACA,sBAAA,QAAA,yGACA,YAAA,QAAA,2EACA,UAAA,QAAA;;;sJCPO,QAAS,WAAU,EAAM,GAC5B,GAAI,GAAQ,GAAI,OAAM,GAAW,EAEjC,OADA,GAAM,KAAO,EACN,EAGJ,QAAS,QAAO,GAAmB,IAAA,GAAA,GAAA,UAAA,OAAR,EAAQ,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAR,EAAQ,EAAA,GAAA,UAAA,EACtC,KAAK,GAAI,GAAI,EAAG,EAAI,EAAO,OAAQ,IAG/B,IAAK,GAFC,GAAQ,EAAO,GAAG,UAClB,EAAQ,OAAO,oBAAoB,GAChC,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACnC,GAAM,GAAO,EAAM,EACnB,IAAa,gBAAT,EAAJ,CAGA,GAAM,GAAa,OAAO,yBAAyB,EAAO,EAC1D,QAAO,eAAe,EAAO,WAAa,EAAQ,EAAM,KAK7D,QAAS,QAAO,EAAQ,GAC3B,GAAM,GAAS,EAAO,WACtB,IAAI,EAEA,IAAK,GADC,GAAQ,OAAO,oBAAoB,GAChC,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACnC,GAAM,GAAO,EAAM,EACnB,GAAO,GAAQ,EAAK,GAG5B,MAAO,GAAO,QAAU,EAGrB,QAAS,uBAAsB,EAAO,GAIzC,IAAK,GAFD,GAAO,KAEF,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACnC,GAAM,GAAO,EAAM,EAEC,iBAAT,KACP,EAAM,GAAK,EAAS,eAAe,IAI3C,GAAqB,IAAjB,EAAM,OACN,EAAO,EAAM,OAEZ,CACD,EAAO,EAAS,wBAEhB,KAAK,GAAI,GAAI,EAAG,EAAI,EAAM,OAAQ,IAC9B,EAAK,YAAY,EAAM,IAI/B,MAAO,GAGJ,QAAS,0BAAyB,GAErC,OAAQ,GACJ,IAAK,iBACL,IAAK,gBACL,IAAK,YACL,IAAK,gBACL,IAAK,gBACL,IAAK,mBACL,IAAK,iBACL,IAAK,gBACD,OAAO,EAIf,GAAM,GAAQ,mDAEd,OAAO,GAAM,KAAK,GAKf,QAAS,WAAU,EAAU,GAMhC,GAAM,GAAS,EAAS,UACxB,KAAK,EACD,MAAO,KAIX,IAAM,GAAS,EAAO,UAGtB,KAAK,EACD,MAAO,KAIX,IAAI,GAAwB,SAAhB,EAAO,KACf,MAAO,KAIX,KAAK,EAAO,WACR,MAAO,KAMX,KAHA,GAAM,GAAO,YAAoB,SAAU,EAAS,aAAa,QAAU,KACrE,IAAW,KAAM,EAAO,WAAY,UAAU,IAE7C,EAAM,QAAQ,CACjB,GAAM,GAAQ,EAAM,MACd,EAAO,EAAM,IAEnB,IAAI,EAAM,SACF,EAAK,aACL,EAAM,MAAO,KAAM,EAAK,YAAa,UAAU,QAGlD,CACD,GAAuB,SAAnB,EAAK,WAAwB,EAAK,aAAa,UAAY,EAC3D,MAAO,EAGX,GAAM,MAAO,KAAM,EAAM,KAAM,UAAU,IAErC,EAAK,YACL,EAAM,MAAO,KAAM,EAAK,WAAY,UAAU,KAK1D,MAAO,MAGJ,QAAS,eAAc,GAK1B,GAAM,MAGA,EAAO,EAAK,aAAc,UAAU,GAC1C,IAAqB,gBAAjB,EAAK,SACL,MAAO,EAQX,KAAK,GAJC,GAAO,EAAK,KAGZ,EAAmB,MAAM,EAAK,YAC3B,EAAI,EAAG,EAAI,EAAiB,OAAQ,IAAK,CAC9C,GAAM,GAAW,EAAiB,EAClC,IAAI,EAAS,WAAa,KAAK,cACxB,EAAS,WAAa,KAAK,UAAW,CAEzC,GAAM,GAAY,UAAU,EAExB,KAAc,GACd,EAAO,KAAK,IAMxB,MAAO,GAGJ,QAAS,wBAAuB,GAKnC,GAAM,MAGA,EAAY,cAAc,EAGhC,IAAyB,IAArB,EAAU,OAEV,IAAK,GADC,GAAmB,MAAM,EAAK,YAC3B,EAAI,EAAG,EAAI,EAAiB,OAAQ,IAAK,CAC9C,GAAM,GAAgB,EAAiB,EACnC,GAAc,WAAa,KAAK,cAC7B,EAAc,WAAa,KAAK,WACnC,EAAU,KAAK,GAM3B,IAAK,GAAI,GAAI,EAAG,EAAI,EAAU,OAAQ,IAAK,CACvC,GAAM,GAAO,EAAU,EAEvB,IAAuB,SAAnB,EAAK,UAAsB,CAC3B,GAAM,GAAkB,uBAAuB,EAC/C,GAAO,OAAP,MAAA,GAAc,EAAO,OAAQ,GAA7B,OAAA,mBAAmC,SAGnC,GAAO,KAAK,GAKpB,MAAO,GAKJ,QAAS,iBAAgB,EAAM,GAMlC,GAAM,GAAY,cAAc,EAIhC,KAAK,EAAmB,CACpB,GAAM,GAAgB,EAAK,eAC3B,IAAI,EAAU,SAAW,EAAc,OACnC,kBAAkB,OAGlB,KAAK,GAAI,GAAI,EAAG,EAAI,EAAU,OAAQ,IAClC,GAAI,EAAU,KAAO,EAAc,GAAI,CACnC,kBAAkB,EAClB,QAOhB,OAAO,GAAQ,cAAe,IAKzB,OAAO,GAAM,YACd,OAAO,GACH,WAAY,MAAM,OAAO,WAAW,IAAI,KAAK,KAMrD,KADA,GAAI,GAAA,OACG,EAAa,OAAO,WAAW,IAAI,KAAK,IAC3C,OAAO,YAAY,KAAK,EAAM,EAIlC,KAAK,GAAI,GAAI,EAAG,EAAI,EAAU,OAAQ,IAAK,CACvC,GAAM,GAAW,EAAU,EAC3B,QAAO,GAAY,aAAc,IACjC,OAAO,YAAY,KAAK,EAAM,GAIlC,IAAK,EAAU,OAEX,IAAK,GADC,GAAa,OAAO,GAAM,WACvB,EAAI,EAAG,EAAI,EAAW,OAAQ,IACnC,OAAO,YAAY,KAAK,EAAM,EAAW,IAK9C,QAAS,yBAAwB,EAAM,GAI1C,GAAM,KAEiB,UAAnB,EAAK,WACL,EAAM,KAAK,GAGX,EAAK,iBACL,EAAM,KAAN,MAAA,EAAA,mBAAc,EAAK,iBAAiB,SAGxC,KAAK,GAAI,GAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACnC,GAAM,GAAO,EAAM,GAGb,EAAoB,EAAc,QAAQ,MAAU,CAG1D,iBAAgB,EAAM,IAIvB,QAAS,aAAY,GACxB,GAAM,GAAO,UAAU,EAEV,QAAT,GACA,gBAAgB,GAMjB,QAAS,mBAAkB,IAa3B,QAAS,4BAA2B,EAAM,EAAQ,GAQrD,GAAI,GAAW,CACf,GACI,IAAI,IAAa,EACb,KAAM,WAAU,+BAGjB,EAAY,EAAS,YAAc,EAAS,KAGnD,IAAc,OAAV,GAAkB,EAAM,aAAe,EACvC,KAAM,WAAU,iBAYjB,QAAS,WAAU,EAAM,EAAQ,GAKpC,2BAA2B,EAAM,EAAQ,EAGzC,IAAI,GAAiB,CAcrB,OAXA,KAAmB,IAAS,EAAiB,EAAK,aAIlD,MAAM,EAAM,EAAO,eAInB,OAAO,EAAM,EAAQ,GAGd,EAGJ,QAAS,QAAO,EAAM,EAAQ,EAAO,GAUxC,GAAI,GAAS,EAAK,WAAa,KAAK,uBAC9B,MAAM,EAAK,aAAe,EAGhC,IAAI,EAAK,WAAa,KAAK,uBACvB,IAAK,GAAI,GAAI,EAAG,EAAI,EAAM,OAAQ,IAC9B,OAAO,EAAM,GAAI,GAAM,EAQ/B,KAAK,GAAI,GAAI,EAAG,EAAI,EAAM,OAAQ,IAAK,CACnC,GAAM,GAAO,EAAM,GAEb,EAAa,OAAO,GAAQ,UAClC,IAAI,EAAY,CACZ,GAAI,EAAO,CACP,GAAM,GAAa,EAAW,QAAQ,EACtC,GAAW,OAAO,EAAY,EAAG,OAGjC,GAAW,KAAK,EAEpB,QAAO,GAAQ,WAAY,GAE3B,IAAM,GAAa,OAAO,GAAQ,IAC9B,IACA,OAAO,aAAa,KAAK,EAAY,EAAM,OAI/C,QAAO,aAAa,KAAK,EAAQ,EAAM,EAIvC,QAAO,GAAQ,YAAc,gBAAkB,IAC/C,YAAY,GAIS,SAArB,EAAO,WAA0D,IAAlC,EAAO,gBAAgB,SAEtD,OAAO,YAAY,KAAK,EAAQ,GAEhC,kBAAkB,GAItB,IAAM,KACiB,UAAnB,EAAK,WACL,EAAyB,KAAK,GAE9B,EAAK,iBACL,EAAyB,KAAzB,MAAA,EAAA,mBAAiC,EAAK,iBAAiB,UAE3D,wBAAwB,EAAM,IAa/B,QAAS,QAAO,EAAM,GAGzB,UAAU,EAAM,EAAQ,MAGrB,QAAS,SAAQ,EAAO,EAAM,GAQjC,GAAI,GAAW,CACf,GACI,IAAI,IAAa,EACb,KAAM,WAAU,+BAGjB,EAAY,EAAS,YAAc,EAAS,KAGnD,IAAc,OAAV,GAAkB,EAAM,aAAe,EACvC,KAAM,WAAU,gBASpB,IAAI,GAAiB,EAAM,WAGvB,KAAmB,IACnB,EAAiB,EAAK,aAQ1B,MAAM,EAAM,EAAO,cAOnB,IAAM,GAAc,EAAM,UACN,QAAhB,GAKA,OAAO,EAAO,GAAQ,GAO1B,OAAO,EAAM,EAAQ,GAAgB,GAOlC,QAAS,YAAW,EAAM,GAKhB,OAAT,GACA,MAAM,EAAM,EAAO,cAYvB,KAAK,GARC,GAAe,MAAM,EAAO,YAQzB,GALoB,OAAT,KACb,EAAK,WAAa,KAAK,uBAA0B,MAAM,EAAK,aAC5D,GAGM,GAAG,EAAI,EAAa,OAAQ,IACrC,OAAO,EAAa,GAAI,GAAQ,EAIvB,QAAT,GACA,OAAO,EAAM,EAAQ,MAAM,GAO5B,QAAS,WAAU,EAAO,GAK7B,GAAI,EAAM,aAAe,EACrB,KAAM,WAAU,gBAOpB,OAHA,QAAO,EAAO,GAGP,EAGJ,QAAS,QAAO,EAAM,EAAQ,GAoBjC,GAAM,GAAa,OAAO,GAAQ,UAClC,IAAI,EAAY,CACZ,GAAM,GAAY,EAAW,QAAQ,EACrC,GAAW,OAAO,EAAW,SAE1B,QAAO,GAAM,WACpB,OAAO,YAAY,KAAK,OAAO,WAAW,IAAI,KAAK,GAAO,EAG1D,IAAM,GAAe,OAAO,GAAM,YAC9B,KACA,gBAAgB,GAChB,OAAO,GAAM,aAAe,MAIP,SAArB,EAAO,WAA0D,IAAlC,EAAO,gBAAgB,QACtD,kBAAkB,EAItB,IAAI,KACmB,UAAnB,EAAK,WACL,EAAyB,KAAK,GAE9B,EAAK,iBACL,EAAyB,KAAzB,MAAA,EAAA,mBAAiC,EAAK,iBAAiB,UAEvD,EAAyB,SAEzB,wBAAwB,GAGxB,wBAAwB,EAAM,IAsB/B,QAAS,OAAM,EAAM,EAAU,GAKlC,EAAW,GAAY,EAAK,aAW5B,IAAM,GAAO,OAAO,UAAU,KAAK,GAAM,EAKzC,IAAI,KAAkB,EAElB,IAAK,GADC,GAAa,MAAM,EAAK,YACrB,EAAI,EAAG,EAAI,EAAW,OAAQ,IACnC,OAAO,EAAW,GAAG,WAAU,GAAO,EAI9C,OAAO,GAGJ,QAAS,OAAM,EAAM,GAIxB,GAGM,IAHY,EAAK,cAGR,EAAK,WACL,QAAX,GACA,OAAO,EAAM,kEAnrBL,UAAA,kBAMA,OAAA,eAeA,OAAA,eAYA,sBAAA,8BA0BA,yBAAA,iCAsBA,UAAA,kBAyDA,cAAA,sBAmCA,uBAAA,+BAyCA,gBAAA,wBA2DA,wBAAA,gCAyBA,YAAA,oBAUA,kBAAA,0BAaA,2BAAA,mCA8BA,UAAA,kBAyBA,OAAA,eAiFA,OAAA,eAMA,QAAA,gBAkEA,WAAA,mBA+BA,UAAA,kBAgBA,OAAA,eA2EA,MAAA,cA+BA,MAAA,KAtrBhB,IAAM,SACF,aAAc,KAAK,UAAU,aAC7B,YAAa,KAAK,UAAU,YAC5B,UAAW,KAAK,UAAU,UAC1B,YAAa,KAAK,UAAU,YAC5B,WAAY,OAAO,yBAAyB,KAAK,UAAW,cAC5D,WAAY,OAAO,yBAAyB,KAAK,UAAW,cAC5D,WAAY,OAAO,yBAAyB,KAAK,UAAW,eAG1D,MAAQ,SAAA,GAAA,MAAS,OAAM,UAAU,MAAM,KAAK",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-customevent\r\n\r\n[Constructor(DOMString type, optional CustomEventInit eventInitDict), Exposed=(Window,Worker)]\r\ninterface CustomEvent : Event\r\n\r\ndictionary CustomEventInit : EventInit {\r\n  any detail = null;\r\n};\r\n\r\n*/\r\n\r\nexport default class extends CustomEvent {\r\n\r\n    constructor(type, eventInitDict) {\r\n        super(type, eventInitDict);\r\n    }\r\n\r\n    // readonly attribute any detail;\r\n\r\n    // void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-document\r\n\r\n[Constructor, Exposed=Window]\r\ninterface Document : Node\r\n\r\n[Exposed=Window]\r\ninterface XMLDocument : Document {};\r\n\r\ndictionary ElementCreationOptions {\r\n  DOMString is;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nconst native = {\r\n    getElementsByTagName: Document.prototype.getElementsByTagName,\r\n    getElementsByTagNameNS: Document.prototype.getElementsByTagNameNS,\r\n    getElementsByClassName: Document.prototype.getElementsByClassName\r\n};\r\n\r\nexport default class extends Document {\r\n\r\n    // TODO: tests\r\n    getElementsByTagName(qualifiedName) {\r\n        const collection = native.getElementsByTagName.call(this, qualifiedName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (this === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByTagNameNS(ns, localName) {\r\n        const collection = native.getElementsByTagNameNS.call(this, ns, localName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (this === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByClassName(names) {\r\n        const collection = native.getElementsByClassName.call(this, name);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (this === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // [NewObject] Element createElement(DOMString localName, optional ElementCreationOptions options);\r\n    // [NewObject] Element createElementNS(DOMString? namespace, DOMString qualifiedName, optional ElementCreationOptions options);\r\n    // [NewObject] DocumentFragment createDocumentFragment();\r\n    // [NewObject] Text createTextNode(DOMString data);\r\n    // [NewObject] CDATASection createCDATASection(DOMString data);\r\n    // [NewObject] Comment createComment(DOMString data);\r\n    // [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);\r\n\r\n    // TODO: tests\r\n    importNode(node, deep) {\r\n        if (node.nodeType === Node.DOCUMENT_NODE || node.nodeName === '#shadow-root') {\r\n            throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        return $.clone(node, this, deep);\r\n    }\r\n\r\n    // [CEReactions, NewObject] Node importNode(Node node, optional boolean deep = false);\r\n    // [CEReactions] Node adoptNode(Node node);\r\n\r\n    // [NewObject] Attr createAttribute(DOMString localName);\r\n    // [NewObject] Attr createAttributeNS(DOMString? namespace, DOMString qualifiedName);\r\n\r\n    // [NewObject] Event createEvent(DOMString interface);\r\n\r\n    // [NewObject] Range createRange();\r\n\r\n    // // NodeFilter.SHOW_ALL = 0xFFFFFFFF\r\n    // [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);\r\n    // [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-element\r\nhttps://www.w3.org/TR/DOM-Parsing/#extensions-to-the-element-interface\r\n\r\n[Exposed=Window]\r\ninterface Element : Node\r\n\r\ndictionary ShadowRootInit {\r\n  required ShadowRootMode mode;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nimport $ShadowRoot from '../interfaces/ShadowRoot.js';\r\n\r\nconst native = {\r\n    getElementsByTagName: Element.prototype.getElementsByTagName,\r\n    getElementsByTagNameNS: Element.prototype.getElementsByTagNameNS,\r\n    getElementsByClassName: Element.prototype.getElementsByClassName,\r\n    innerHTML: Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML'),\r\n    outerHTML: Object.getOwnPropertyDescriptor(Element.prototype, 'outerHTML'),\r\n    insertAdjacentElement: Element.prototype.insertAdjacentElement,\r\n    insertAdjacentHTML: Element.prototype.insertAdjacentHTML,\r\n    insertAdjacentText: Element.prototype.insertAdjacentText\r\n};\r\n\r\nexport default class extends Element {\r\n\r\n    get slot() {\r\n        // The slot attribute must reflect the \"slot\" content attribute.\r\n        return this.getAttribute('slot');\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    // Track slot name changes\r\n    // Possibly need to intercept setAttribute?\r\n    set slot(value) {\r\n        // The slot attribute must reflect the \"slot\" content attribute.\r\n        this.setAttribute('slot', value);\r\n    }\r\n\r\n    attachShadow(init) {\r\n        // https://dom.spec.whatwg.org/#dom-element-attachshadow\r\n        if (!init || (init.mode !== 'open' && init.mode !== 'closed')) {\r\n            throw $.makeError('TypeError');\r\n        }\r\n\r\n        if (this.namespaceURI !== 'http://www.w3.org/1999/xhtml') {\r\n            throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        switch (this.localName) {\r\n            case \"article\": case \"aside\": case \"blockquote\": case \"body\": \r\n            case \"div\": case \"footer\": case \"h1\": case \"h2\": case \"h3\":\r\n            case \"h4\": case \"h5\": case \"h6\": case \"header\": case \"main\":\r\n            case \"nav\": case \"p\": case \"section\": case \"span\":\r\n                break;\r\n            default:\r\n                if ($.isValidCustomElementName(this.localName)) {\r\n                    break;\r\n                }\r\n                throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        if (this.shadowRoot) {\r\n            throw $.makeError('InvalidStateError');\r\n        }\r\n\r\n        const shadow = this.ownerDocument.createDocumentFragment();\r\n        \r\n        $.extend(shadow, $ShadowRoot);\r\n\r\n        $.shadow(shadow, {\r\n            host: this,\r\n            mode: init.mode,\r\n            childNodes: []\r\n        });\r\n\r\n        $.shadow(this, {\r\n            shadowRoot: shadow,\r\n            childNodes: Array.prototype.slice.call(this.childNodes)\r\n        });\r\n\r\n        const childNodes = $.shadow(this).childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            $.shadow(childNodes[i], {\r\n                parentNode: this\r\n            });\r\n        }\r\n\r\n        native.innerHTML.set.call(this, null);\r\n\r\n        return shadow;\r\n    }\r\n\r\n    get shadowRoot() {\r\n        // https://dom.spec.whatwg.org/#dom-element-shadowroot\r\n        \r\n        let shadowRoot = $.shadow(this).shadowRoot;\r\n\r\n        if (!shadowRoot || shadowRoot.mode === 'closed') {\r\n            return null;\r\n        }\r\n\r\n        return shadowRoot;\r\n    }\r\n\r\n    // TODO: tests\r\n    closest(selectors) {\r\n        let element = this;\r\n\r\n        do {\r\n            if (element.matches(selectors)) {\r\n                return element;\r\n            }\r\n        }\r\n        while (element = element.parentElement);\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByTagName(qualifiedName) {\r\n        const contextRoot = this.getRootNode({ composed: false });\r\n        const collection = native.getElementsByTagName.call(this, qualifiedName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (contextRoot === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByTagNameNS(ns, localName) {\r\n        const contextRoot = this.getRootNode({ composed: false });\r\n        const collection = native.getElementsByTagNameNS.call(this, ns, localName);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (contextRoot === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: tests\r\n    getElementsByClassName(names) {\r\n        const contextRoot = this.getRootNode({ composed: false });\r\n        const collection = native.getElementsByClassName.call(this, name);\r\n        const filtered = [];\r\n\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection[i];\r\n            if (contextRoot === item.getRootNode({ composed: false })) {\r\n                filtered.push(item)\r\n            }\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    insertAdjacentElement(where, element) {\r\n        return native.insertAdjacentElement.call(this, where, text);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    insertAdjacentText(where, data) {\r\n        return native.insertAdjacentText.call(this, where, data);\r\n    }\r\n\r\n    // https://w3c.github.io/DOM-Parsing/#extensions-to-the-element-interface\r\n\r\n    // TODO: impl, tests\r\n    get innerHTML() {\r\n        return native.innerHTML.get.call(this);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    set innerHTML(value) {\r\n        return native.innerHTML.set.call(this, value);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    get outerHTML() {\r\n        return native.outerHTML.get.call(this);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    set outerHTML(value) {\r\n        return native.outerHTML.set.call(this, value);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    insertAdjacentHTML(position, text) {\r\n        return native.insertAdjacentHTML.call(this, position, text);\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-event\r\n\r\n[Constructor(DOMString type, optional EventInit eventInitDict), Exposed=(Window,Worker)]\r\ninterface Event\r\n\r\n*/\r\n\r\nconst $composed = new WeakMap();\r\n\r\nexport default class extends Event {\r\n\r\n    constructor(type, eventInitDict) {\r\n        super(type, eventInitDict);\r\n\r\n        $composed.set(this, (eventInitDict && eventInitDict.composed === true));\r\n    }\r\n\r\n    // readonly attribute DOMString type;\r\n    // readonly attribute EventTarget? target;\r\n    // readonly attribute EventTarget? currentTarget;\r\n    // sequence<EventTarget> composedPath();\r\n\r\n    // TODO: impl, tests\r\n    composedPath() {\r\n        // https://dom.spec.whatwg.org/#dom-event-composedpath\r\n\r\n        const composedPath = [];\r\n        const currentTarget = this.currentTarget;\r\n\r\n        // TODO: implement event path and retargeting\r\n        const path = calculatePath(this);\r\n\r\n        if (currentTarget instanceof Window) {\r\n            for (const tuple of path) {\r\n                const item = tuple.item;\r\n                if (item instanceof Node) {\r\n                    if (!item.closedShadowHidden) {\r\n                        composedPath.push(item);\r\n                    }\r\n                }\r\n                else {\r\n                    composedPath.push(item);\r\n                }\r\n            }\r\n        }\r\n        else if (currentTarget instanceof Node) {\r\n            for (const tuple of path) {\r\n                const item = tuple.item;\r\n                if (!item.closedShadowHidden) {\r\n                    composedPath.push(item);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            composedPath.push(...path);\r\n        }\r\n\r\n        return composedPath;\r\n    }\r\n\r\n    // const unsigned short NONE = 0;\r\n    // const unsigned short CAPTURING_PHASE = 1;\r\n    // const unsigned short AT_TARGET = 2;\r\n    // const unsigned short BUBBLING_PHASE = 3;\r\n    // readonly attribute unsigned short eventPhase;\r\n\r\n    // void stopPropagation();\r\n    // void stopImmediatePropagation();\r\n\r\n    // readonly attribute boolean bubbles;\r\n    // readonly attribute boolean cancelable;\r\n    // void preventDefault();\r\n    // readonly attribute boolean defaultPrevented;\r\n    // readonly attribute boolean composed;\r\n\r\n    get composed() {\r\n        return $composed.get(this);\r\n    }\r\n\r\n    // [Unforgeable] readonly attribute boolean isTrusted;\r\n    // readonly attribute DOMTimeStamp timeStamp;\r\n\r\n    // void initEvent(DOMString type, boolean bubbles, boolean cancelable); // historical\r\n\r\n}\r\n\r\n/*\r\n\r\ndictionary EventInit {\r\n  boolean bubbles = false;\r\n  boolean cancelable = false;\r\n  boolean composed = false;\r\n};\r\n\r\n*/",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-eventtarget\r\n\r\n[Exposed=(Window,Worker)]\r\ninterface EventTarget\r\n\r\n*/\r\n\r\nexport default class extends EventTarget {\r\n\r\n    // void addEventListener(DOMString type, EventListener? callback, optional (AddEventListenerOptions or boolean) options);\r\n    // void removeEventListener(DOMString type, EventListener? callback, optional (EventListenerOptions or boolean) options);\r\n    // boolean dispatchEvent(Event event);\r\n\r\n}\r\n\r\n/*\r\n\r\ncallback interface EventListener {\r\n  void handleEvent(Event event);\r\n};\r\n\r\ndictionary EventListenerOptions {\r\n  boolean capture = false;\r\n};\r\n\r\ndictionary AddEventListenerOptions : EventListenerOptions {\r\n  boolean passive = false;\r\n  boolean once = false;\r\n};\r\n\r\n*/",
    "/*\r\n\r\nhttps://html.spec.whatwg.org/multipage/scripting.html#the-slot-element\r\n\r\ninterface HTMLSlotElement : HTMLElement\r\n\r\ndictionary AssignedNodesOptions {\r\n    boolean flatten = false;\r\n};\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class extends HTMLUnknownElement {\r\n\r\n    // TODO: tests\r\n    get name() {\r\n        return this.getAttribute('name');\r\n    }\r\n\r\n    // TODO: tests\r\n    set name(value) {\r\n        this.setAttribute('name', value);\r\n    }\r\n\r\n    // TODO: tests\r\n    assignedNodes(options) {\r\n        if (this.localName !== 'slot') {\r\n            return;\r\n        }\r\n\r\n        // https://html.spec.whatwg.org/multipage/scripting.html#dom-slot-assignednodes\r\n        // The assignedNodes(options) method, when invoked, must run these steps:\r\n\r\n        // 1. If the value of options's flatten member is false, then return this element's assigned nodes.\r\n        if (!options || options.flatten !== true) {\r\n            return $.shadow(this).assignedNodes;\r\n        }\r\n\r\n        // 2. Return the result of finding flattened slotables with this element.\r\n        return $.findFlattenedSlotables(this);    \r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://www.w3.org/TR/html5/single-page.html#the-table-element\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class extends HTMLTableElement {\r\n\r\n    deleteCaption() {\r\n        const caption = this.caption;\r\n        if (caption) {\r\n            $.remove(caption, this);\r\n        }\r\n    }\r\n\r\n    deleteTHead() {\r\n        const tHead = this.tHead;\r\n        if (tHead) {\r\n            $.remove(tHead, this);\r\n        }\r\n    }\r\n\r\n    deleteTFoot() {\r\n        const tFoot = this.tFoot;\r\n        if (tFoot) {\r\n            $.remove(tFoot, this);\r\n        }\r\n    }\r\n\r\n    deleteRow(index) {\r\n        // https://www.w3.org/TR/html5/single-page.html#dom-table-deleterow\r\n        if (index === -1) {\r\n            index = this.rows.length - 1;\r\n        }\r\n        if (index < 0 || index >= this.rows.length) {\r\n            throw $.makeError('IndexSizeError');\r\n        }\r\n        this.rows[index].remove();\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://www.w3.org/TR/html5/single-page.html#the-tr-element\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class extends HTMLTableRowElement {\r\n\r\n    deleteCell(index) {\r\n        // https://www.w3.org/TR/html5/single-page.html#dom-tr-deletecell\r\n        if (index === -1) {\r\n            index = this.cells.length - 1;\r\n        }\r\n        if (index < 0 || index >= this.cells.length) {\r\n            throw $.makeError('IndexSizeError');\r\n        }\r\n        this.cells[index].remove();\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://www.w3.org/TR/html5/single-page.html#the-tbody-element\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class extends HTMLTableSectionElement {\r\n\r\n    deleteRow(index) {\r\n        // https://www.w3.org/TR/html5/single-page.html#dom-tbody-deleterow\r\n        if (index < 0 || index >= this.rows.length) {\r\n            throw $.makeError('IndexSizeError');\r\n        }\r\n        this.rows[index].remove();\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-node\r\n\r\n[Exposed=Window]\r\ninterface Node : EventTarget\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nconst native = {\r\n    parentNode: Object.getOwnPropertyDescriptor(Node.prototype, 'parentNode'),\r\n    parentElement: Object.getOwnPropertyDescriptor(Node.prototype, 'parentElement'),\r\n    hasChildNodes: Node.prototype.hasChildNodes,\r\n    childNodes: Object.getOwnPropertyDescriptor(Node.prototype, 'childNodes'),\r\n    firstChild: Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild'),\r\n    lastChild: Object.getOwnPropertyDescriptor(Node.prototype, 'lastChild'),\r\n    previousSibling: Object.getOwnPropertyDescriptor(Node.prototype, 'previousSibling'),\r\n    nextSibling: Object.getOwnPropertyDescriptor(Node.prototype, 'nextSibling'),\r\n    textContent: Object.getOwnPropertyDescriptor(Node.prototype, 'textContent'),\r\n    normalize: Node.prototype.normalize\r\n};\r\n\r\nexport default class extends Node {\r\n\r\n    getRootNode(options) {\r\n        // https://dom.spec.whatwg.org/#dom-node-getrootnode\r\n\r\n        const composed = options && (options.composed === true);\r\n\r\n        let root, ancestor;\r\n\r\n        root = ancestor = this;\r\n\r\n        if (!composed) {\r\n            while (ancestor = ancestor.parentNode) {\r\n                root = ancestor;\r\n            }\r\n\r\n            return root;\r\n        }\r\n\r\n        while (ancestor = ancestor.parentNode) {\r\n            root = ancestor;\r\n\r\n            if (root.nodeName === '#shadow-root') {\r\n                root = ancestor = root.host;\r\n            }\r\n        }\r\n\r\n        return root;\r\n    }\r\n\r\n    get parentNode() {\r\n        const parentNode = $.shadow(this).parentNode;\r\n        if (parentNode) {\r\n            return parentNode;\r\n        }\r\n\r\n        return native.parentNode.get.call(this);\r\n    }\r\n\r\n    get parentElement() {\r\n        const parentNode = $.shadow(this).parentNode;\r\n        if (parentNode) {\r\n            if (parentNode.nodeType === Node.ELEMENT_NODE) {\r\n                return parentNode;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        return native.parentElement.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    hasChildNodes() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            return childNodes.length > 0;\r\n        }\r\n\r\n        return native.hasChildNodes.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get childNodes() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            return childNodes.slice();\r\n        }\r\n\r\n        return native.childNodes.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get firstChild() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            if (childNodes.length) {\r\n                return childNodes[0];\r\n            }\r\n            return null;\r\n        }\r\n\r\n        return native.firstChild.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get lastChild() {\r\n        const childNodes = $.shadow(this).childNodes;\r\n        if (childNodes) {\r\n            if (childNodes.length) {\r\n                return childNodes[childNodes.length - 1];\r\n            }\r\n            return null;\r\n        }\r\n\r\n        return native.lastChild.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get previousSibling() {\r\n        const parentNode = $.shadow(this).parentNode;\r\n        if (parentNode) {\r\n            const childNodes = $.shadow(parentNode).childNodes;\r\n            const siblingIndex = childNodes.indexOf(this) - 1;\r\n            return siblingIndex < 0 ? null : childNodes[siblingIndex];\r\n        }\r\n\r\n        return native.previousSibling.get.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    get nextSibling() {\r\n        const parentNode = $.shadow(this).parentNode;\r\n        if (parentNode) {\r\n            const childNodes = $.shadow(parentNode).childNodes;\r\n            const siblingIndex = childNodes.indexOf(this) + 1;\r\n            return siblingIndex === childNodes.length ? null : childNodes[siblingIndex];\r\n        }\r\n\r\n        return native.nextSibling.get.call(this);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    get textContent() {\r\n        return native.textContent.get.call(this);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    set textContent(value) {\r\n        return native.textContent.set.call(this, value);\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    normalize() {\r\n        // https://dom.spec.whatwg.org/#dom-node-normalize\r\n        // The normalize() method, when invoked, must run these steps \r\n        // for each descendant exclusive Text node node of context object:\r\n        return native.normalize.call(this);\r\n    }\r\n\r\n    // TODO: tests\r\n    cloneNode(deep) {\r\n        // https://dom.spec.whatwg.org/#dom-node-clonenode\r\n        // The cloneNode(deep) method, when invoked, must run these steps:\r\n\r\n        // 1. If context object is a shadow root, then throw a NotSupportedError.\r\n        if (this.nodeName === '#shadow-root') {\r\n            throw $.makeError('NotSupportedError');\r\n        }\r\n\r\n        // 2. Return a clone of the context object, with the clone children flag set if deep is true.\r\n        return $.clone(this, undefined, deep);\r\n    }\r\n\r\n    // TODO: tests\r\n    isEqualNode(other) {\r\n        // https://dom.spec.whatwg.org/#dom-node-isequalnode\r\n        // https://dom.spec.whatwg.org/#concept-node-equals\r\n        if (!other) {\r\n            return false;\r\n        }\r\n\r\n        if (this.nodeType !== other.nodeType) {\r\n            return false;\r\n        }\r\n\r\n        switch (this.nodeType) {\r\n            case Node.DOCUMENT_TYPE_NODE:\r\n                if (this.name !== other.name ||\r\n                    this.publicId !== other.publicId ||\r\n                    this.systemId !== other.systemId) {\r\n                    return false;\r\n                }\r\n            case Node.ELEMENT_NODE:\r\n                if (this.namespaceURI !== other.namespaceURI ||\r\n                    this.prefix !== other.prefix ||\r\n                    this.localName !== other.localName ||\r\n                    this.attributes.length !== other.attributes.length) {\r\n                    return false;\r\n                }\r\n            case Node.ATTRIBUTE_NODE:\r\n                if (this.namespaceURI !== other.namespaceURI ||\r\n                    this.localName !== other.localName ||\r\n                    this.value !== other.value) {\r\n                    return false;\r\n                }\r\n            case Node.PROCESSING_INSTRUCTION_NODE:\r\n                if (this.target !== other.target ||\r\n                    this.data !== other.data) {\r\n                    return false;\r\n                }\r\n            case Node.TEXT_NODE:\r\n            case Node.COMMENT_NODE:\r\n                if (this.data !== other.data) {\r\n                    return false;\r\n                }\r\n        }\r\n\r\n        if (this.nodeType == Node.ELEMENT_NODE) {\r\n            for (let i = 0; i < this.attributes.length; i++) {\r\n                let attr1 = this.attributes[i];\r\n                let attr2 = other.attributes[attr1.name];\r\n                if (attr1.value !== attr2.value) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        let childNodes1 = this.childNodes;\r\n        let childNodes2 = other.childNodes;\r\n        if (childNodes1.length !== other.childNodes.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < childNodes1.length; i++) {\r\n            if (!childNodes1[i].isEqualNode(childNodes2[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // TODO: tests\r\n    compareDocumentPosition(other) {\r\n        // https://dom.spec.whatwg.org/#dom-node-comparedocumentposition\r\n\r\n        if (this === other) {\r\n            return 0;\r\n        }\r\n\r\n        let node1 = other;\r\n        let node2 = this;\r\n        let attr1 = null;\r\n        let attr2 = null;\r\n\r\n        if (node1.nodeType == Document.prototype.ATTRIBUTE_NODE) {\r\n            attr1 = node1;\r\n            node1 = attr1.ownerElement;\r\n        }\r\n\r\n        if (node2.nodeType == Document.prototype.ATTRIBUTE_NODE) {\r\n            attr2 = node2;\r\n            node2 = attr2.ownerElement;\r\n\r\n            if (attr1 && node1 && node2 === node1) {\r\n                let attrs = node2.atttributes;\r\n                for (var i = 0; i < attrs.length; i++) {\r\n                    const attr = attrs[i];\r\n                    if (attr.isEqualNode(attr1)) {\r\n                        return Document.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\r\n                            + Document.prototype.DOCUMENT_POSITION_PRECEDING;\r\n                    }\r\n                    else if (attr.isEqualNode(attr2)) {\r\n                        return Document.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\r\n                            + Document.prototype.DOCUMENT_POSITION_FOLLOWING;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!node1 || !node2 || node1.getRootNode() !== node2.getRootNode()) {\r\n            return Document.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\r\n                + Document.prototype.DOCUMENT_POSITION_FOLLOWING\r\n                + Document.prototype.DOCUMENT_POSITION_DISCONNECTED;\r\n        }\r\n\r\n        if (ancestorOf(node2, node1) || ((node1 === node2) && attr2)) {\r\n            return Document.prototype.DOCUMENT_POSITION_CONTAINS\r\n                + Document.prototype.DOCUMENT_POSITION_PRECEDING;\r\n        }\r\n\r\n        if (ancestorOf(node1, node2) || ((node1 === node2) && attr1)) {\r\n            return Document.prototype.DOCUMENT_POSITION_CONTAINS\r\n                + Document.prototype.DOCUMENT_POSITION_FOLLOWING;\r\n        }\r\n\r\n        if (preceding(node1, node2)) {\r\n            return Document.prototype.DOCUMENT_POSITION_PRECEDING;\r\n        }\r\n\r\n        return Document.prototype.DOCUMENT_POSITION_FOLLOWING;\r\n    }\r\n\r\n    // TODO: tests\r\n    contains(node) {\r\n        // https://dom.spec.whatwg.org/#dom-node-contains\r\n\r\n        let parent = node.parentNode;\r\n\r\n        if (!parent) {\r\n            return false;\r\n        }\r\n\r\n        do {\r\n            if (parent === this) {\r\n                return true;\r\n            }\r\n        }\r\n        while (parent = parent.parentNode);\r\n\r\n        return false;\r\n    }\r\n\r\n    // TODO: tests\r\n    insertBefore(node, child) {\r\n        // https://dom.spec.whatwg.org/#dom-node-insertbefore\r\n        // The insertBefore(node, child) method, when invoked, must return the result \r\n        // of pre-inserting node into context object before child.\r\n        return $.preInsert(node, this, child);\r\n    }\r\n\r\n    // TODO: tests\r\n    appendChild(node) {\r\n        // https://dom.spec.whatwg.org/#dom-node-appendchild\r\n        // The appendChild(node) method, when invoked, must return the result of \r\n        // appending node to context object.\r\n        return $.append(node, this);\r\n    }\r\n\r\n    // TODO: tests\r\n    replaceChild(node, child) {\r\n        // https://dom.spec.whatwg.org/#dom-node-replacechild\r\n        // The replaceChild(node, child) method, when invoked, must return the \r\n        // result of replacing child with node within context object.\r\n        return $.replace(child, node, this);\r\n    }\r\n\r\n    // TODO: tests\r\n    removeChild(child) {\r\n        // https://dom.spec.whatwg.org/#dom-node-removechild\r\n        // The removeChild(child) method, when invoked, must return the result of \r\n        // pre-removing child from context object.\r\n        return $.preRemove(child, this);\r\n    }\r\n\r\n}\r\n\r\nfunction ancestorOf(node, ancestor) {\r\n    let parent = node.parentNode;\r\n\r\n    do {\r\n        if (parent === ancestor) {\r\n            return true;\r\n        }\r\n    }\r\n    while (parent = parent.parentNode);\r\n\r\n    return false;\r\n}\r\n\r\nfunction preceding(element1, element2) {\r\n    function precedingSiblings(parent, sibling1, sibling2) {\r\n        let siblings = parent.childNodes;\r\n        for (let i = 0; i < siblings.length; i++) {\r\n            let sibling = siblings[i];\r\n            if (sibling === sibling1) {\r\n                return true;\r\n            }\r\n            else if (sibling === sibling2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check if they're already siblings.\r\n    let ancestor1 = element1.parentNode;\r\n    let ancestor2 = element2.parentNode;\r\n\r\n    if (ancestor1 === ancestor2) {\r\n        return precedingSiblings(element1, element2);\r\n    }\r\n\r\n    // Find the closest common ancestor.\r\n    let ancestors1 = [ancestor1];\r\n    let ancestors2 = [ancestor2];\r\n\r\n    while (ancestor1 = ancestor1.parentNode) {\r\n        ancestors1.push(ancestor1);\r\n    }\r\n\r\n    while (ancestor2 = ancestor2.parentNode) {\r\n        ancestors2.push(ancestor2);\r\n    }\r\n\r\n    ancestors1.reverse();\r\n    ancestors2.reverse();\r\n\r\n    let diff = Math.abs(ancestors1.length - ancestors2.length);\r\n    let min = Math.min(ancestors1.length, ancestors2.length);\r\n\r\n    let i = 0;\r\n    while (ancestors1[i] === ancestors2[i]) {\r\n        i++;\r\n    }\r\n\r\n    return precedingSiblings(ancestors1[i - 1], ancestors1[i], ancestors2[i]);\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-shadowroot\r\nhttps://www.w3.org/TR/shadow-dom/#the-shadowroot-interface\r\n\r\n[Exposed=Window]\r\ninterface ShadowRoot : DocumentFragment\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default class extends DocumentFragment {\r\n\r\n    // TODO: tests\r\n    get nodeName() {\r\n        return '#shadow-root';\r\n    }\r\n\r\n    // TODO: tests\r\n    get mode() {\r\n        return $.shadow(this).mode;\r\n    }\r\n\r\n    // TODO: tests\r\n    get host() {\r\n        return $.shadow(this).host;\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    get innerHTML() {\r\n    }\r\n\r\n    // TODO: impl, tests\r\n    set innerHTML(value) {\r\n    }\r\n\r\n}",
    "import patch from './patch.js';\r\n\r\nconst nativeShadowDom = 'attachShadow' in Element.prototype;\r\n\r\nif (!nativeShadowDom || window.forceShadowDomPolyfill) {\r\n    patch();\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-childnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface ChildNode\r\n\r\nDocumentType implements ChildNode;\r\nElement implements ChildNode;\r\nCharacterData implements ChildNode;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default base => class extends base {\r\n\r\n    // TODO: tests\r\n    before(...nodes) {\r\n        // https://dom.spec.whatwg.org/#dom-childnode-before\r\n        // The before(nodes) method, when invoked, must run these steps:\r\n\r\n        // 1. Let parent be context objects parent.\r\n        const parent = this.parentNode;\r\n\r\n        // 2. If parent is null, terminate these steps.\r\n        if (!parent) {\r\n            return;\r\n        }\r\n\r\n        // 3. Let viablePreviousSibling be context objects first preceding \r\n        // sibling not in nodes, and null otherwise.\r\n        let viablePreviousSibling = this.previousSibling;\r\n        while (viablePreviousSibling && nodes.indexOf(viablePreviousSibling) !== -1) {\r\n            viablePreviousSibling = viablePreviousSibling.previousSibling;\r\n        }\r\n\r\n        // 4. Let node be the result of converting nodes into a node, given \r\n        // nodes and context objects node document. Rethrow any exceptions.\r\n        const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n\r\n        // 5. If viablePreviousSibling is null, set it to parents first child, \r\n        // and to viablePreviousSiblings next sibling otherwise.\r\n        if (viablePreviousSibling === null) {\r\n            viablePreviousSibling = parent.firstChild;\r\n        }\r\n        else {\r\n            viablePreviousSibling = viablePreviousSibling.nextSibling;\r\n        }\r\n\r\n        // 6. Pre-insert node into parent before viablePreviousSibling. \r\n        // Rethrow any exceptions.\r\n        $.preInsert(node, parent, viablePreviousSibling);\r\n    }\r\n\r\n    // TODO: tests\r\n    after(...nodes) {\r\n        // https://dom.spec.whatwg.org/#dom-childnode-after\r\n        // The after(nodes) method, when invoked, must run these steps:\r\n\r\n        // 1. Let parent be context objects parent.\r\n        const parent = this.parentNode;\r\n\r\n        // 2. If parent is null, terminate these steps.\r\n        if (!parent) {\r\n            return;\r\n        }\r\n\r\n        // 3. Let viableNextSibling be context objects first following \r\n        // sibling not in nodes, and null otherwise.\r\n        let viableNextSibling = this.nextSibling;\r\n        while (viableNextSibling && nodes.indexOf(viableNextSibling) !== -1) {\r\n            viableNextSibling = viableNextSibling.nextSibling;\r\n        }\r\n\r\n        // 4. Let node be the result of converting nodes into a node, given \r\n        // nodes and context objects node document. Rethrow any exceptions.\r\n        const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n        \r\n        // 5. Pre-insert node into parent before viableNextSibling. Rethrow \r\n        // any exceptions.\r\n        $.preInsert(node, parent, viableNextSibling);\r\n    }\r\n\r\n    // TODO: tests\r\n    replaceWith(...nodes) {\r\n        // https://dom.spec.whatwg.org/#dom-childnode-replacewith\r\n        // The replaceWith(nodes) method, when invoked, must run these steps:\r\n\r\n        // 1. Let parent be context objects parent.\r\n        const parent = this.parentNode;\r\n\r\n        // 2. If parent is null, terminate these steps.\r\n        if (!parent) {\r\n            return;\r\n        }\r\n\r\n        // 3. Let viableNextSibling be context objects first following \r\n        // sibling not in nodes, and null otherwise.\r\n        let viableNextSibling = this.nextSibling;\r\n        while (viableNextSibling && nodes.indexOf(viableNextSibling) !== -1) {\r\n            viableNextSibling = viableNextSibling.nextSibling;\r\n        }\r\n\r\n        // 4. Let node be the result of converting nodes into a node, given \r\n        // nodes and context objects node document. Rethrow any exceptions.\r\n        const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n\r\n        // 5. If context objects parent is parent, replace the context object \r\n        // with node within parent. Rethrow any exceptions.\r\n        if (this.parentNode == parent) {\r\n            parent.replaceChild(this, node);\r\n        }\r\n        // 6. Otherwise, pre-insert node into parent before viableNextSibling. \r\n        // Rethrow any exceptions.\r\n        else {\r\n            parent.insertBefore(node, viableNextSibling);\r\n        }\r\n    }\r\n\r\n    // TODO: tests\r\n    remove() {\r\n        // https://dom.spec.whatwg.org/#dom-childnode-remove\r\n        // The remove() method, when invoked, must run these steps:\r\n\r\n        // 1. If context objects parent is null, terminate these steps.\r\n        const parent = this.parentNode;\r\n\r\n        if (!parent) {\r\n            return;\r\n        }\r\n\r\n        // 2. Remove the context object from context objects parent.\r\n        $.remove(this, parent);\r\n    }\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#mixin-documentorshadowroot\r\nhttps://www.w3.org/TR/shadow-dom/#extensions-to-the-documentorshadowroot-mixin\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface DocumentOrShadowRoot\r\n\r\nDocument implements DocumentOrShadowRoot;\r\nShadowRoot implements DocumentOrShadowRoot;\r\n\r\n*/\r\n\r\nexport default function (base) {\r\n\r\n    const native = {\r\n        activeElement: Object.getOwnPropertyDescriptor(base.prototype, 'activeElement')\r\n    };\r\n\r\n    return class extends base {\r\n\r\n        /*\r\n    \r\n        https://www.w3.org/TR/shadow-dom/#extensions-to-the-documentorshadowroot-mixin\r\n    \r\n        */\r\n\r\n        // Selection?        getSelection();\r\n        // Element?          elementFromPoint(double x, double y);\r\n        // sequence<Element> elementsFromPoint(double x, double y);\r\n        // CaretPosition?    caretPositionFromPoint(double x, double y);\r\n        // readonly attribute Element?       activeElement;\r\n        // readonly attribute StyleSheetList styleSheets;\r\n\r\n        // TODO: tests\r\n        get activeElement() {\r\n            return native.activeElement.get.call(this);\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-nondocumenttypechildnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface NonDocumentTypeChildNode\r\n\r\nElement implements NonDocumentTypeChildNode;\r\nCharacterData implements NonDocumentTypeChildNode;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function (base) {\r\n\r\n    const native = {\r\n        previousElementSibling: Object.getOwnPropertyDescriptor(base.prototype, 'previousElementSibling'),\r\n        nextElementSibling: Object.getOwnPropertyDescriptor(base.prototype, 'nextElementSibling')\r\n    };\r\n\r\n    return class extends base {\r\n\r\n        // TODO: tests\r\n        get previousElementSibling() {\r\n            const parentNode = $.shadow(this).parentNode;\r\n            if (parentNode) {\r\n                const childNodes = $.shadow(parentNode).childNodes;\r\n                let index = childNodes.indexOf(this);\r\n\r\n                if (index === 0) {\r\n                    return null;\r\n                }\r\n\r\n                do {\r\n                    const previous = childNodes[--index];\r\n\r\n                    if (previous.nodeType === Node.ELEMENT_NODE) {\r\n                        return previous;\r\n                    }\r\n                }\r\n                while (index > 0);\r\n\r\n                return null;\r\n            }\r\n\r\n            return native.previousElementSibling.get.call(this);\r\n        }\r\n\r\n        // TODO: tests\r\n        get nextElementSibling() {\r\n            const parentNode = $.shadow(this).parentNode;\r\n            if (parentNode) {\r\n                const childNodes = $.shadow(parentNode).childNodes;\r\n                let index = childNodes.indexOf(this);\r\n\r\n                if (index === childNodes.length - 1) {\r\n                    return null;\r\n                }\r\n\r\n                do {\r\n                    const previous = childNodes[++index];\r\n\r\n                    if (previous.nodeType === Node.ELEMENT_NODE) {\r\n                        return previous;\r\n                    }\r\n                }\r\n                while (index < childNodes.length);\r\n\r\n                return null;\r\n            }\r\n\r\n            return native.nextElementSibling.get.call(this);\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-nonelementparentnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface NonElementParentNode\r\n\r\nDocument implements NonElementParentNode;\r\nDocumentFragment implements NonElementParentNode;\r\n\r\n*/\r\n\r\nexport default function (base) {\r\n\r\n    const native = {\r\n        getElementById: base.prototype.getElementById\r\n    };\r\n\r\n    return class extends base {\r\n\r\n        // TODO: tests\r\n        getElementById(id) {\r\n            // https://dom.spec.whatwg.org/#dom-nonelementparentnode-getelementbyid\r\n\r\n            // If the native implementation returns a correct element, go with that.\r\n\r\n            const candidateResult = native.getElementById.call(this, id);\r\n            const candidateRoot = candidateResult.getRootNode({ composed: false });\r\n\r\n            if (this === candidateRoot) {\r\n                return candidateResult;\r\n            }\r\n\r\n            // Otherwise, go through our polyfilled algorithm.\r\n\r\n            let firstChild = this.firstChild;\r\n\r\n            if (!firstChild) {\r\n                return null;\r\n            }\r\n\r\n            const stack = [{ node: firstChild, recursed: false }];\r\n\r\n            while (stack.length) {\r\n                const frame = stack.pop();\r\n\r\n                if (frame.recursed) {\r\n                    if (frame.node.nextSibling) {\r\n                        stack.push({ node: frame.node.nextSibling, recursed: false });\r\n                    }\r\n                }\r\n                else {\r\n                    if (frame.node.id === id) {\r\n                        return frame.node;\r\n                    }\r\n\r\n                    stack.push({ node: frame.node, recursed: true });\r\n\r\n                    if (firstChild = frame.node.firstChild) {\r\n                        stack.push({ node: firstChild, recursed: false });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#interface-parentnode\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface ParentNode\r\n\r\nDocument implements ParentNode;\r\nDocumentFragment implements ParentNode;\r\nElement implements ParentNode;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default function (base) {\r\n\r\n    const native = {\r\n        children: Object.getOwnPropertyDescriptor(base.prototype, 'children'),\r\n        firstElementChild: Object.getOwnPropertyDescriptor(base.prototype, 'firstElementChild'),\r\n        lastElementChild: Object.getOwnPropertyDescriptor(base.prototype, 'lastElementChild'),\r\n        childElementCount: Object.getOwnPropertyDescriptor(base.prototype, 'childElementCount'),\r\n    };\r\n\r\n    return class extends base {\r\n\r\n        // TODO: tests\r\n        get children() {\r\n            const childNodes = $.shadow(this).childNodes;\r\n            if (childNodes) {\r\n                let elements = [];\r\n                for (let i = 0; i < childNodes.length; i++) {\r\n                    const node = childNodes[i];\r\n                    if (node.nodeType == Node.ELEMENT_NODE) {\r\n                        elements.push(node);\r\n                    }\r\n                }\r\n\r\n                return elements;\r\n            }\r\n\r\n            return native.children.get.call(this);\r\n        }\r\n\r\n        // TODO: tests\r\n        get firstElementChild() {\r\n            const childNodes = $.shadow(this).childNodes;\r\n            if (childNodes) {\r\n                for (let i = 0; i < childNodes.length; i++) {\r\n                    const node = childNodes[i];\r\n                    if (node.nodeType == Node.ELEMENT_NODE) {\r\n                        return node;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            return native.firstElementChild.get.call(this);\r\n        }\r\n\r\n        // TODO: tests\r\n        get lastElementChild() {\r\n            const childNodes = $.shadow(this).childNodes;\r\n            if (childNodes) {\r\n                for (let i = childNodes.length - 1; i >= 0; i--) {\r\n                    const node = childNodes[i];\r\n                    if (node.nodeType == Node.ELEMENT_NODE) {\r\n                        return node;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            return native.lastElementChild.get.call(this);\r\n        }\r\n\r\n        // TODO: tests\r\n        get childElementCount() {\r\n            const childNodes = $.shadow(this).childNodes;\r\n            if (childNodes) {\r\n                let count = 0;\r\n                for (let i = 0; i < childNodes.length; i++) {\r\n                    const node = childNodes[i];\r\n                    if (node.nodeType == Node.ELEMENT_NODE) {\r\n                        count++;\r\n                    }\r\n                }\r\n                return count;\r\n            }\r\n\r\n            return native.childElementCount.get.call(this);\r\n        }\r\n\r\n        // TODO: tests\r\n        prepend(...nodes) {\r\n            // https://dom.spec.whatwg.org/#dom-parentnode-prepend\r\n            // The prepend(nodes) method, when invoked, must run these steps:\r\n\r\n            // 1. Let node be the result of converting nodes into a node given \r\n            // nodes and context objects node document. Rethrow any exceptions.\r\n            const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n\r\n            // 2. Pre-insert node into context object before the context objects \r\n            // first child. Rethrow any exceptions.\r\n            $.preInsert(node, this, this.firstChild);\r\n        }\r\n\r\n        // TODO: tests\r\n        append(...nodes) {\r\n            // https://dom.spec.whatwg.org/#dom-parentnode-append\r\n            // The append(nodes) method, when invoked, must run these steps:\r\n\r\n            // 1. Let node be the result of converting nodes into a node given \r\n            // nodes and context objects node document. Rethrow any exceptions.\r\n            const node = $.convertNodesIntoANode(nodes, this.ownerDocument);\r\n\r\n            // 2. Append node to context object. Rethrow any exceptions.\r\n            $.append(node, this);\r\n        }\r\n\r\n        // TODO: tests\r\n        querySelector(selectors) {\r\n            const results = this.querySelectorAll(selectors);\r\n\r\n            if (results.length) {\r\n                return results[0];\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        // TODO: tests\r\n        querySelectorAll(selectors) {\r\n            // https://dom.spec.whatwg.org/#scope-match-a-selectors-string\r\n            // this is horrible, performance-wise.\r\n            // it's about 100x slower than native querySelectorAll.\r\n            // that might not amount to much in practice, though.\r\n            // after all, this is a polyfill.\r\n\r\n            let firstChild = this.firstChild;\r\n\r\n            if (!firstChild) {\r\n                return null;\r\n            }\r\n\r\n            const stack = [{ node: firstChild, recursed: false }];\r\n            const results = [];\r\n\r\n            while (stack.length) {\r\n                const frame = stack.pop();\r\n\r\n                if (frame.recursed) {\r\n                    if (frame.node.nextSibling) {\r\n                        stack.push({ node: frame.node.nextSibling, recursed: false });\r\n                    }\r\n                }\r\n                else {\r\n                    if (frame.node.nodeType == Node.ELEMENT_NODE && frame.node.matches(selectors)) {\r\n                        results.push(frame.node);\r\n                    }\r\n\r\n                    stack.push({ node: frame.node, recursed: true });\r\n\r\n                    if (firstChild = frame.node.firstChild) {\r\n                        stack.push({ node: firstChild, recursed: false });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return results;\r\n        }\r\n\r\n    };\r\n\r\n}",
    "/*\r\n\r\nhttps://dom.spec.whatwg.org/#mixin-slotable\r\n\r\n[NoInterfaceObject, Exposed=Window]\r\ninterface Slotable\r\n\r\nElement implements Slotable;\r\nText implements Slotable;\r\n\r\n*/\r\n\r\nimport * as $ from '../utils.js';\r\n\r\nexport default base => class extends base {\r\n\r\n    // TODO: tests\r\n    get assignedSlot() {\r\n        // TODO: efficiency\r\n        return $.findASlot(this, true);\r\n    }\r\n\r\n}",
    "import * as $ from './utils.js';\r\n\r\nimport $CustomEvent from './interfaces/CustomEvent.js';\r\nimport $Document from './interfaces/Document.js';\r\nimport $Element from './interfaces/Element.js';\r\nimport $Event from './interfaces/Event.js';\r\nimport $EventTarget from './interfaces/EventTarget.js';\r\nimport $HTMLSlotElement from './interfaces/HTMLSlotElement.js';\r\nimport $HTMLTableElement from './interfaces/HTMLTableElement.js';\r\nimport $HTMLTableSectionElement from './interfaces/HTMLTableSectionElement.js';\r\nimport $HTMLTableRowElement from './interfaces/HTMLTableRowElement.js';\r\nimport $Node from './interfaces/Node.js';\r\nimport $ShadowRoot from './interfaces/ShadowRoot.js';\r\n\r\nimport $ChildNode from './mixins/ChildNode.js';\r\nimport $DocumentOrShadowRoot from './mixins/DocumentOrShadowRoot.js';\r\nimport $NonDocumentTypeChildNode from './mixins/NonDocumentTypeChildNode.js';\r\nimport $NonElementParentNode from './mixins/NonElementParentNode.js';\r\nimport $ParentNode from './mixins/ParentNode.js';\r\nimport $Slotable from './mixins/Slotable.js';\r\n\r\nexport default function() {\r\n    // Globally applied interfaces\r\n\r\n    //$.extend(CustomEvent, $CustomEvent);\r\n    $.extend(Document, $Document);\r\n    $.extend(Element, $Element);\r\n    //$.extend(Event, $Event);\r\n    //$.extend(EventTarget, $EventTarget);\r\n    $.extend(HTMLUnknownElement, $HTMLSlotElement);\r\n    if ('HTMLSlotElement' in window) {\r\n        // In case we are forcing a polyfill\r\n        $.extend(HTMLSlotElement, $HTMLSlotElement);\r\n    }\r\n    $.extend(HTMLTableElement, $HTMLTableElement);\r\n    $.extend(HTMLTableSectionElement, $HTMLTableSectionElement);\r\n    $.extend(HTMLTableRowElement, $HTMLTableRowElement);\r\n    $.extend(Node, $Node);\r\n\r\n    // Globally applied mixins\r\n\r\n    $.extend(DocumentType, $ChildNode(DocumentType));\r\n    $.extend(Element, $ChildNode(Element));\r\n    $.extend(CharacterData, $ChildNode(CharacterData));\r\n\r\n    $.extend(Document, $DocumentOrShadowRoot(Document));\r\n    $.extend($ShadowRoot, $DocumentOrShadowRoot($ShadowRoot));\r\n\r\n    $.extend(Element, $NonDocumentTypeChildNode(Element));\r\n    $.extend(CharacterData, $NonDocumentTypeChildNode(CharacterData));\r\n\r\n    $.extend(Document, $NonElementParentNode(Document));\r\n    $.extend(DocumentFragment, $NonElementParentNode(DocumentFragment));\r\n\r\n    $.extend(Document, $ParentNode(Document));\r\n    $.extend(DocumentFragment, $ParentNode(DocumentFragment));\r\n    $.extend(Element, $ParentNode(Element));\r\n\r\n    $.extend(Element, $Slotable(Element));\r\n    $.extend(Text, $Slotable(Text));\r\n}",
    "const native = {\r\n    insertBefore: Node.prototype.insertBefore,\r\n    removeChild: Node.prototype.removeChild,\r\n    cloneNode: Node.prototype.cloneNode,\r\n    appendChild: Node.prototype.appendChild,\r\n    parentNode: Object.getOwnPropertyDescriptor(Node.prototype, 'parentNode'),\r\n    firstChild: Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild'),\r\n    childNodes: Object.getOwnPropertyDescriptor(Node.prototype, 'childNodes')\r\n};\r\n\r\nconst slice = array => Array.prototype.slice.call(array);\r\n\r\nexport function makeError(name, message) {\r\n    var error = new Error(message || name);\r\n    error.name = name;\r\n    return error;\r\n}\r\n\r\nexport function extend(object, ...mixins) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        const mixin = mixins[i].prototype;\r\n        const names = Object.getOwnPropertyNames(mixin);\r\n        for (let j = 0; j < names.length; j++) {\r\n            const name = names[j];\r\n            if (name === 'constructor') {\r\n                continue;\r\n            }\r\n            const descriptor = Object.getOwnPropertyDescriptor(mixin, name);\r\n            Object.defineProperty(object.prototype || object, name, descriptor);\r\n        }\r\n    }\r\n}\r\n\r\nexport function shadow(object, info) {\r\n    const shadow = object._shadow || {};\r\n    if (info) {\r\n        const names = Object.getOwnPropertyNames(info);\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i];\r\n            shadow[name] = info[name];\r\n        }\r\n    }\r\n    return object._shadow = shadow;\r\n}\r\n\r\nexport function convertNodesIntoANode(nodes, document) {\r\n    // https://dom.spec.whatwg.org/#converting-nodes-into-a-node\r\n    let node = null;\r\n\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const item = nodes[i];\r\n\r\n        if (typeof item === \"string\") {\r\n            nodes[i] = document.createTextNode(item);\r\n        }\r\n    }\r\n\r\n    if (nodes.length === 1) {\r\n        node = nodes[0];\r\n    }\r\n    else {\r\n        node = document.createDocumentFragment();\r\n\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            node.appendChild(nodes[i]);\r\n        }\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\nexport function isValidCustomElementName(localName) {\r\n    // https://html.spec.whatwg.org/multipage/scripting.html#valid-custom-element-name\r\n    switch (localName) {\r\n        case \"annotation-xml\":\r\n        case \"color-profile\":\r\n        case \"font-face\":\r\n        case \"font-face-src\":\r\n        case \"font-face-uri\":\r\n        case \"font-face-format\":\r\n        case \"font-face-name\":\r\n        case \"missing-glyph\":\r\n            return false;\r\n    }\r\n\r\n    // For now, to reduce complexity, we are leaving the unicode sets out...\r\n    const regex = /[a-z](-|\\.|[0-9]|_|[a-z])+-(-|\\.|[0-9]|_|[a-z])+/g;\r\n\r\n    return regex.test(localName);\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#finding-slots-and-slotables\r\n\r\nexport function findASlot(slotable, open) {\r\n    // https://dom.spec.whatwg.org/#find-a-slot\r\n    // To find a slot for a given slotable slotable and an optional \r\n    // open flag (unset unless stated otherwise), run these steps:\r\n\r\n    // 1. If slotables parent is null, then return null.\r\n    const parent = slotable.parentNode;\r\n    if (!parent) {\r\n        return null;\r\n    }\r\n\r\n    // 2. Let shadow be slotables parents shadow root.\r\n    const shadow = parent.shadowRoot;\r\n\r\n    // 3. If shadow is null, then return null.\r\n    if (!shadow) {\r\n        return null;\r\n    }\r\n\r\n    // 4. If the open flag is set and shadows mode is not \"open\", then return null.\r\n    if (open && shadow.mode !== 'open') {\r\n        return null;\r\n    }\r\n\r\n    // 5. Return the first slot in shadows tree whose name is slotables name, if any, and null otherwise.\r\n    if (!shadow.firstChild) {\r\n        return null;\r\n    }\r\n\r\n    const name = slotable instanceof Element ? slotable.getAttribute('slot') : null;\r\n    const stack = [{ node: shadow.firstChild, recursed: false }];\r\n\r\n    while (stack.length) {\r\n        const frame = stack.pop();\r\n        const node = frame.node;\r\n\r\n        if (frame.recursed) {\r\n            if (node.nextSibling) {\r\n                stack.push({ node: node.nextSibling, recursed: false });\r\n            }\r\n        }\r\n        else {\r\n            if (node.localName === 'slot' && node.getAttribute('name') === name) {\r\n                return node;\r\n            }\r\n\r\n            stack.push({ node: frame.node, recursed: true });\r\n\r\n            if (node.firstChild) {\r\n                stack.push({ node: node.firstChild, recursed: false });\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function findSlotables(slot) {\r\n    // https://dom.spec.whatwg.org/#find-slotables\r\n    // To find slotables for a given slot slot, run these steps:\r\n\r\n    // 1. Let result be an empty list.\r\n    const result = [];\r\n\r\n    // 2. If slots root is not a shadow root, then return result.\r\n    const root = slot.getRootNode({ composed: false });\r\n    if (root.nodeName != '#shadow-root') {\r\n        return result;\r\n    }\r\n\r\n    // 3. Let host be slots roots host.\r\n    const host = root.host;\r\n\r\n    // 4. For each slotable child of host, slotable, in tree order, run these substeps:\r\n    const slotableChildren = slice(host.childNodes);\r\n    for (let i = 0; i < slotableChildren.length; i++) {\r\n        const slotable = slotableChildren[i];\r\n        if (slotable.nodeType === Node.ELEMENT_NODE \r\n            || slotable.nodeType === Node.TEXT_NODE) {\r\n            // 1. Let foundSlot be the result of finding a slot given slotable.\r\n            const foundSlot = findASlot(slotable);\r\n            // 2. If foundSlot is slot, then append slotable to result.\r\n            if (foundSlot === slot) {\r\n                result.push(slotable);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 5. Return result.\r\n    return result;\r\n}\r\n\r\nexport function findFlattenedSlotables(slot) {\r\n    // https://dom.spec.whatwg.org/#find-flattened-slotables\r\n    // To find flattened slotables for a given slot slot, run these steps:\r\n\r\n    // 1. Let result be an empty list.\r\n    const result = [];\r\n\r\n    // 2. Let slotables be the result of finding slotables given slot.\r\n    const slotables = findSlotables(slot);\r\n\r\n    // 3. If slotables is the empty list, then append each slotable child of slot, in tree order, to slotables.\r\n    if (slotables.length === 0) {\r\n        const slotableChildren = slice(slot.childNodes);\r\n        for (let i = 0; i < slotableChildren.length; i++) {\r\n            const slotableChild = slotableChildren[i];\r\n            if (slotableChild.nodeType === Node.ELEMENT_NODE \r\n                || slotableChild.nodeType === Node.TEXT_NODE) {\r\n                slotables.push(slotableChild);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 4. For each node in slotables, run these substeps:\r\n    for (let i = 0; i < slotables.length; i++) {\r\n        const node = slotables[i];\r\n        // 1. If node is a slot, run these subsubsteps:\r\n        if (node.localName === 'slot') {\r\n            const temporaryResult = findFlattenedSlotables(node);\r\n            result.splice(result.length, 0, ...temporaryResult);\r\n        }\r\n        else {\r\n            result.push(node);\r\n        }\r\n    }\r\n\r\n    // 5. Return result.\r\n    return result;\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#assigning-slotables-and-slots\r\n\r\nexport function assignSlotables(slot, suppressSignaling) {\r\n    // https://dom.spec.whatwg.org/#assign-slotables\r\n    // To assign slotables, for a slot slot with an optional suppress \r\n    // signaling flag (unset unless stated otherwise), run these steps:\r\n\r\n    // 1. Let slotables be the result of finding slotables for slot.\r\n    const slotables = findSlotables(slot);\r\n\r\n    // 2. If suppress signaling flag is unset, and slotables and slots assigned \r\n    // nodes are not identical, then run signal a slot change for slot.\r\n    if (!suppressSignaling) {\r\n        const assignedNodes = slot.assignedNodes();\r\n        if (slotables.length !== assignedNodes.length) {\r\n            signalASlotChange(slot);\r\n        }\r\n        else {\r\n            for (let i = 0; i < slotables.length; i++) {\r\n                if (slotables[i] !== assignedNodes[i]) {\r\n                    signalASlotChange(slot);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 3. Set slots assigned nodes to slotables.\r\n    shadow(slot, { assignedNodes: slotables });\r\n\r\n    // 4. For each slotable in slotables, set slotables assigned slot to slot.\r\n\r\n    // 4a. If we haven't tracked them yet, track the slot's logical children\r\n    if (!shadow(slot).childNodes) {\r\n        shadow(slot, {\r\n            childNodes: slice(native.childNodes.get.call(slot))\r\n        });\r\n    }\r\n\r\n    // 4b. We need to clean out the slot\r\n    let firstChild;\r\n    while (firstChild = native.firstChild.get.call(slot)) {\r\n        native.removeChild.call(slot, firstChild);\r\n    }\r\n\r\n    // 4c. do what the spec said\r\n    for (let i = 0; i < slotables.length; i++) {\r\n        const slotable = slotables[i];\r\n        shadow(slotable, { assignedSlot: slot });\r\n        native.appendChild.call(slot, slotable);\r\n    }\r\n\r\n    // 4d. if there were no slotables we need to insert its fallback content\r\n    if (!slotables.length) {\r\n        const childNodes = shadow(slot).childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            native.appendChild.call(slot, childNodes[i]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function assignSlotablesForATree(tree, noSignalSlots) {\r\n    // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\r\n    // To assign slotables for a tree, given a tree tree and an optional set of slots noSignalSlots\r\n    // (empty unless stated otherwise), run these steps for each slot slot in tree, in tree order:\r\n    const slots = [];\r\n\r\n    if (tree.localName === 'slot') {\r\n        slots.push(tree);\r\n    }\r\n\r\n    if (tree.hasChildNodes()) {\r\n        slots.push(...tree.querySelectorAll('slot'));\r\n    }\r\n\r\n    for (let i = 0; i < slots.length; i++) {\r\n        const slot = slots[i];\r\n\r\n        // 1. Let suppress signaling flag be set, if slot is in noSignalSlots, and unset otherwise.\r\n        const suppressSignaling = noSignalSlots.indexOf(slot) !== -1;\r\n\r\n        // 2. Run assign slotables for slot with suppress signaling flag.\r\n        assignSlotables(slot, suppressSignaling);\r\n    }\r\n}\r\n\r\nexport function assignASlot(slotable) {\r\n    const slot = findASlot(slotable);\r\n\r\n    if (slot !== null) {\r\n        assignSlotables(slot);\r\n    }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#signaling-slot-change\r\n\r\nexport function signalASlotChange(slot) {\r\n    // https://dom.spec.whatwg.org/#signal-a-slot-change\r\n    // To signal a slot change, for a slot slot, run these steps:\r\n\r\n    // Skip (MutationObserver)\r\n    // 1. If slot is not in unit of related similar-origin browsing contexts' \r\n    // signal slot list, append slot to unit of related similar-origin browsing \r\n    // contexts' signal slot list.\r\n    // 2. Queue a mutation observer compound microtask.\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#mutation-algorithms\r\n\r\nexport function ensurePreInsertionValidity(node, parent, child) {\r\n    // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\r\n    // To ensure pre-insertion validity of a node into a parent before a child, run these steps:\r\n\r\n    // Skip (native)\r\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a HierarchyRequestError.\r\n\r\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\r\n    let ancestor = parent;\r\n    do {\r\n        if (ancestor === node) {\r\n            throw makeError('HierarchyRequestError');\r\n        }\r\n    }\r\n    while (ancestor = (ancestor.parentNode || ancestor.host));\r\n\r\n    // 3. If child is not null and its parent is not parent, then throw a NotFoundError.\r\n    if (child !== null && child.parentNode !== parent) {\r\n        throw makeError('NotFoundError');\r\n    }\r\n\r\n    // Skip (native)\r\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, \r\n    // or Comment node, throw a HierarchyRequestError.\r\n    // 5. If either node is a Text node and parent is a document, or node is a doctype \r\n    // and parent is not a document, throw a HierarchyRequestError.\r\n    // 6. If parent is a document, and any of the statements below, switched on node, \r\n    // are true, throw a HierarchyRequestError.\r\n}\r\n\r\nexport function preInsert(node, parent, child) {\r\n    // https://dom.spec.whatwg.org/#concept-node-pre-insert\r\n    // To pre-insert a node into a parent before a child, run these steps:\r\n\r\n    // 1. Ensure pre-insertion validity of node into parent before child.\r\n    ensurePreInsertionValidity(node, parent, child);\r\n\r\n    // 2. Let reference child be child.\r\n    let referenceChild = child;\r\n\r\n    // 3. If reference child is node, set it to nodes next sibling.\r\n    referenceChild === node && (referenceChild = node.nextSibling);\r\n\r\n    // 4. Adopt node into parents node document.\r\n    // https://dom.spec.whatwg.org/#concept-node-adopt\r\n    adopt(node, parent.ownerDocument);\r\n\r\n    // 5. Insert node into parent before reference child.\r\n    // https://dom.spec.whatwg.org/#concept-node-insert\r\n    insert(node, parent, referenceChild);\r\n\r\n    // 6. Return node.\r\n    return node;\r\n}\r\n\r\nexport function insert(node, parent, child, suppressObservers) {\r\n    // https://dom.spec.whatwg.org/#concept-node-insert\r\n    // To insert a node into a parent before a child, with an optional suppress observers flag, run these steps:\r\n\r\n    // Skip (Range)\r\n    // 1. Let count be the number of children of node if it is a DocumentFragment node, and one otherwise.\r\n    // 2. If child is non-null, run these substeps:\r\n\r\n    // 3. Let nodes be nodes children if node is a DocumentFragment node, \r\n    // and a list containing solely node otherwise.\r\n    let nodes = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) \r\n        ? slice(node.childNodes) : [node];\r\n\r\n    // 4. If node is a DocumentFragment node, remove its children with the suppress observers flag set.\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            remove(nodes[i], node, true);\r\n        }\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 5. If node is a DocumentFragment node, queue a mutation record of \"childList\" for node with removedNodes nodes.\r\n\r\n    // 6. For each node in nodes, in tree order, run these substeps:\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        // 1. Insert node into parent before child or at the end of parent if child is null.\r\n        const childNodes = shadow(parent).childNodes;\r\n        if (childNodes) {\r\n            if (child) {\r\n                const childIndex = childNodes.indexOf(child);\r\n                childNodes.splice(childIndex, 0, node);\r\n            }\r\n            else {\r\n                childNodes.push(node);\r\n            }\r\n            shadow(node, { parentNode: parent });\r\n            // If it's a shadow root, perform physical insert on the host.\r\n            const shadowHost = shadow(parent).host;\r\n            if (shadowHost) {\r\n                native.insertBefore.call(shadowHost, node, child);\r\n            }\r\n        }\r\n        else {\r\n            native.insertBefore.call(parent, node, child);\r\n        }\r\n\r\n        // 2. If parent is a shadow host and node is a slotable, then assign a slot for node.\r\n        if (shadow(parent).shadowRoot && 'assignedSlot' in node) {\r\n            assignASlot(node);\r\n        }\r\n\r\n        // 3. If parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.\r\n        if (parent.localName === 'slot' && parent.assignedNodes().length === 0) {\r\n            // 3a. Physically append the child into the slot.\r\n            native.appendChild.call(parent, node);\r\n            // 3b. Do what the spec said\r\n            signalASlotChange(parent);\r\n        }\r\n\r\n        // 4. Run assign slotables for a tree with nodes tree and a set containing each inclusive descendant of node that is a slot.\r\n        const inclusiveSlotDescendants = [];\r\n        if (node.localName === 'slot') {\r\n            inclusiveSlotDescendants.push(node);\r\n        }\r\n        if (node.hasChildNodes()) {\r\n            inclusiveSlotDescendants.push(...node.querySelectorAll('slot'));\r\n        }\r\n        assignSlotablesForATree(node, inclusiveSlotDescendants);\r\n\r\n        // Skip (CustomElements)\r\n        // 5. For each shadow-including inclusive descendant inclusiveDescendant of node, \r\n        // in shadow-including tree order, run these subsubsteps:\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 7. If suppress observers flag is unset, queue a mutation record of \"childList\" for parent \r\n    // with addedNodes nodes, nextSibling child, and previousSibling childs previous sibling or \r\n    // parents last child if child is null.\r\n}\r\n\r\nexport function append(node, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-append\r\n    // To append a node to a parent, pre-insert node into parent before null.\r\n    preInsert(node, parent, null);\r\n}\r\n\r\nexport function replace(child, node, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-replace\r\n    // To replace a child with node within a parent, run these steps:\r\n\r\n    // Skip (native)\r\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a HierarchyRequestError.\r\n\r\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\r\n    let ancestor = parent;\r\n    do {\r\n        if (ancestor === node) {\r\n            throw makeError('HierarchyRequestError');\r\n        }\r\n    }\r\n    while (ancestor = (ancestor.parentNode || ancestor.host));\r\n\r\n    // 3. If childs parent is not parent, then throw a NotFoundError.\r\n    if (child !== null && child.parentNode !== parent) {\r\n        throw makeError('NotFoundError');\r\n    }\r\n\r\n    // Skip (native)\r\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or Comment node, throw a HierarchyRequestError.\r\n    // 5. If either node is a Text node and parent is a document, or node is a doctype and parent is not a document, throw a HierarchyRequestError.\r\n    // 6. If parent is a document, and any of the statements below, switched on node, are true, throw a HierarchyRequestError.\r\n\r\n    // 7. Let reference child be childs next sibling.\r\n    let referenceChild = child.nextSibling;\r\n\r\n    // 8. If reference child is node, set it to nodes next sibling.\r\n    if (referenceChild === node) {\r\n        referenceChild = node.nextSibling;\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 9. Let previousSibling be childs previous sibling.\r\n    // const previousSibling = child.previousSibling;\r\n\r\n    // 10. Adopt node into parents node document.\r\n    adopt(node, parent.ownerDocument);\r\n\r\n    // Skip (MutationObserver)\r\n    // 11. Let removedNodes be the empty list.\r\n    // const removedNodes = [];\r\n\r\n    // 12. If childs parent is not null, run these substeps:\r\n    const childParent = child.parentNode;\r\n    if (childParent !== null) {\r\n        // Skip (MutationObserver)\r\n        // 1. Set removedNodes to a list solely containing child.\r\n        // removedNodes.push(child);\r\n        // 2. Remove child from its parent with the suppress observers flag set.\r\n        remove(child, parent, true);\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 13. Let nodes be nodes children if node is a DocumentFragment node, and a list containing solely node otherwise.\r\n\r\n    // 14. Insert node into parent before reference child with the suppress observers flag set.\r\n    insert(node, parent, referenceChild, true);\r\n\r\n    // Skip (MutationObserver)\r\n    // 15. Queue a mutation record of \"childList\" for target parent with addedNodes nodes, \r\n    // removedNodes removedNodes, nextSibling reference child, and previousSibling previousSibling.\r\n}\r\n\r\nexport function replaceAll(node, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-replace-all\r\n    // To replace all with a node within a parent, run these steps:\r\n\r\n    // 1. If node is not null, adopt node into parents node document.\r\n    if (node !== null) {\r\n        adopt(node, parent.ownerDocument);\r\n    }\r\n\r\n    // 2. Let removedNodes be parents children.\r\n    const removedNodes = slice(parent.childNodes);\r\n\r\n    // 3. Let addedNodes be the empty list if node is null, nodes children if node is a DocumentFragment node, and a list containing node otherwise.\r\n    const addedNodes = (node === null) ? [] \r\n        : (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) ? slice(node.childNodes)\r\n        : [node];\r\n\r\n    // 4. Remove all parents children, in tree order, with the suppress observers flag set.\r\n    for (let i = 0; i < removedNodes.length; i++) {\r\n        remove(removedNodes[i], parent, true);\r\n    }\r\n\r\n    // 5. If node is not null, insert node into parent before null with the suppress observers flag set.\r\n    if (node !== null) {\r\n        insert(node, parent, null, true);\r\n    }\r\n\r\n    // Skip (MutationObserver)\r\n    // 6. Queue a mutation record of \"childList\" for parent with addedNodes addedNodes and removedNodes removedNodes.\r\n}\r\n\r\nexport function preRemove(child, parent) {\r\n    // https://dom.spec.whatwg.org/#concept-node-pre-remove\r\n    // To pre-remove a child from a parent, run these steps:\r\n\r\n    // 1. If childs parent is not parent, then throw a NotFoundError.\r\n    if (child.parentNode !== parent) {\r\n        throw makeError('NotFoundError');\r\n    }\r\n\r\n    // 2. Remove child from parent.\r\n    remove(child, parent);\r\n\r\n    // 3. Return child.\r\n    return child;\r\n}\r\n\r\nexport function remove(node, parent, suppessObservers) {\r\n    // https://dom.spec.whatwg.org/#concept-node-remove\r\n    // To remove a node from a parent, with an optional suppress observers flag, run these steps:\r\n\r\n    // Skip (Range)\r\n    // 1. Let index be nodes index.\r\n    // 2. For each range whose start node is an inclusive descendant of node, set its start to (parent, index).\r\n    // 3. For each range whose end node is an inclusive descendant of node, set its end to (parent, index).\r\n    // 4. For each range whose start node is parent and start offset is greater than index, decrease its start offset by one.\r\n    // 5. For each range whose end node is parent and end offset is greater than index, decrease its end offset by one.\r\n\r\n    // Skip (NodeIterator)\r\n    // 6. For each NodeIterator object iterator whose roots node document is nodes node document, \r\n    // run the NodeIterator pre-removing steps given node and iterator.\r\n\r\n    // Skip (MutationObserver)\r\n    // 7. Let oldPreviousSibling be nodes previous sibling.\r\n    // 8. Let oldNextSibling be nodes next sibling.\r\n\r\n    // 9. Remove node from its parent.\r\n    const childNodes = shadow(parent).childNodes;\r\n    if (childNodes) {\r\n        const nodeIndex = childNodes.indexOf(node);\r\n        childNodes.splice(nodeIndex, 1);\r\n    }\r\n    delete shadow(node).parentNode;\r\n    native.removeChild.call(native.parentNode.get.call(node), node);\r\n\r\n    // 10. If node is assigned, then run assign slotables for nodes assigned slot.\r\n    const assignedSlot = shadow(node).assignedSlot;\r\n    if (assignedSlot) {\r\n        assignSlotables(assignedSlot);\r\n        shadow(node).assignedSlot = null;\r\n    }\r\n\r\n    // 11. If parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.\r\n    if (parent.localName === 'slot' && parent.assignedNodes().length === 0) {\r\n        signalASlotChange(parent);\r\n    }\r\n\r\n    // 12. If node has an inclusive descendant that is a slot, then:\r\n    let inclusiveSlotDescendants = [];\r\n    if (node.localName === 'slot') {\r\n        inclusiveSlotDescendants.push(node);\r\n    }\r\n    if (node.hasChildNodes()) {\r\n        inclusiveSlotDescendants.push(...node.querySelectorAll('slot'));\r\n    }\r\n    if (inclusiveSlotDescendants.length) {\r\n        // 1. Run assign slotables for a tree with parents tree.\r\n        assignSlotablesForATree(parent);\r\n        // 2. Run assign slotables for a tree with nodes tree and a \r\n        // set containing each inclusive descendant of node that is a slot.\r\n        assignSlotablesForATree(node, inclusiveSlotDescendants);\r\n    }\r\n\r\n    // Skip (other)\r\n    // 13. Run the removing steps with node and parent.\r\n\r\n    // Skip (CustomElements)\r\n    // 14. If node is custom, then enqueue a custom element callback reaction \r\n    // with node, callback name \"disconnectedCallback\", and an empty argument list.\r\n    // 15. For each shadow-including descendant descendant of node, in \r\n    // shadow-including tree order, run these substeps:\r\n\r\n    // Skip (MutationObserver)\r\n    // 16. For each inclusive ancestor inclusiveAncestor of parent, if inclusiveAncestor \r\n    // has any registered observers whose options' subtree is true, then for each such registered \r\n    // observer registered, append a transient registered observer whose observer and options are \r\n    // identical to those of registered and source which is registered to nodes list of registered observers.\r\n    // 17. If suppress observers flag is unset, queue a mutation record of \"childList\" for parent \r\n    // with removedNodes a list solely containing node, nextSibling oldNextSibling, and previousSibling \r\n    // oldPreviousSibling.\r\n}\r\n\r\nexport function clone(node, document, cloneChildren) {\r\n    // https://dom.spec.whatwg.org/#concept-node-clone\r\n    // To clone a node, with an optional document and clone children flag, run these steps:\r\n\r\n    // 1. If document is not given, let document be nodes node document.\r\n    document = document || node.ownerDocument;\r\n\r\n    // Use a shortcut here\r\n    // 2. If node is an element, then:\r\n    // 3. Otherwise, let copy be a node that implements the same interfaces \r\n    // as node, and fulfills these additional requirements, switching on node:\r\n    // 4. Set copys node document and document to copy, if copy is a document, \r\n    // and set copys node document to document otherwise.\r\n    // 5. Run any cloning steps defined for node in other applicable \r\n    // specifications and pass copy, node, document and the clone children \r\n    // flag if set, as parameters.\r\n    const copy = native.cloneNode.call(node, false);\r\n\r\n    // 6. If the clone children flag is set, clone all the children of node \r\n    // and append them to copy, with document as specified and the clone \r\n    // children flag being set.\r\n    if (cloneChildren === true) {\r\n        const childNodes = slice(node.childNodes);\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            append(childNodes[i].cloneNode(true), copy);\r\n        }\r\n    }\r\n\r\n    return copy;\r\n}\r\n\r\nexport function adopt(node, document) {\r\n    // https://dom.spec.whatwg.org/#concept-node-adopt\r\n\r\n    // 1. Let oldDocument be nodes node document.\r\n    let oldDocument = node.ownerDocument;\r\n\r\n    // 2. If nodes parent is not null, remove node from its parent.\r\n    const parent = node.parentNode;\r\n    if (parent !== null) {\r\n        remove(node, parent);\r\n    }\r\n\r\n    // Skip (CustomElements, native)\r\n    // 3. If document is not the same as oldDocument, run these substeps:\r\n}"
  ]
}